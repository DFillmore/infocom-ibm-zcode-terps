	TITLE	far_read

_TEXT	SEGMENT	BYTE PUBLIC 'CODE'
_TEXT	ENDS
NULL	SEGMENT WORD PUBLIC 'BEGDATA'
NULL	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
EXTRN	_printabt:BYTE
EXTRN	_diskabt:BYTE
EXTRN	_cridevi:WORD
tret	dw	0
_DATA	ENDS
_BSS	SEGMENT	WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	_BSS, _DATA, NULL
	ASSUME	CS: _TEXT, DS: DGROUP, SS:DGROUP, ES:DGROUP

_TEXT	SEGMENT
EXTRN	_do_error:NEAR
EXTRN	_dos_fatal:NEAR

; Args are file handle, segment, offset, # bytes 
	PUBLIC	_far_read,_far_write,_zopen,_zcreat,_crterr,_do_copy
	PUBLIC	_get_segreg,_zdumpfont,_zusrfont,_zclose

; return a segment register.  1 is cs, 2 is ds, 3 is es.

_get_segreg	PROC NEAR
	push	bp
	mov	bp,sp
	mov	ax,[bp+4]
	cmp	ax,1
	je	gsr1
	cmp	ax,2
	je	gsr2
	mov	ax,es
	jmp	short gsrdon
gsr1:	mov	ax,cs
	jmp	short gsrdon
gsr2:	mov	ax,ds
gsrdon:	mov	sp,bp
	pop	bp
	ret
_get_segreg	ENDP



; Args are: seg of source (or 0 for current ds), offset of source,
; seg of dest (or 0), offset of dest, number of BYTES to copy.
_do_copy	PROC NEAR
	push	bp
	mov	bp,sp
	push	si
	push	di
	push	es
	push	ds
	push	cx
	mov	cx,[bp+8]
	cmp	cx,0
	jne	dc1
	mov	cx,ds
dc1:	mov	es,cx
	mov	cx,[bp+4]
	cmp	cx,0
	jne	dc2
	mov	cx,ds
dc2:	mov	ds,cx
	mov	si,[bp+6]
	mov	di,[bp+10]
	mov	cx,[bp+12]
	cld
	rep	movsb			; Do the copy
	pop	cx
	pop	ds
	pop	es
	pop	di
	pop	si
	mov	sp,bp
	pop	bp
	ret

_do_copy	ENDP

_far_write	PROC NEAR

	push	bp
	mov	bp,sp
	mov	_diskabt,0
	push	ds
	mov	ah,40H		; Write Handle
	mov	bx,[bp+6]
	cmp	bx,0
	je	fwnos
	mov	ds,bx
fwnos:	mov	bx,[bp+4]
	mov	cx,[bp+10]
	mov	dx,[bp+8]
	int	21H
	jnc	fwret
	not	ax
	add	ax,1		; add one for correct negative number
fwret:	pop	ds
	mov	sp,bp
	pop	bp
	ret
_far_write	ENDP

_far_read	PROC NEAR

	push	bp
	mov	bp,sp		; our frame pointer?
	push	ds		; save the data segment
	mov	_diskabt,0
	mov	ah,3fH		; Read Handle function
	mov	bx,[bp+6]
	cmp	bx,0
	je	frnos
	mov	ds,bx
frnos:	mov	bx,[bp+4]	; handle
	mov	cx,[bp+10]	; last arg--# bytes
	mov	dx,[bp+8]	; offset
	int	21H		; do it
	jnc	frret
	push	ax		; just die
	call	_dos_fatal
	not	ax		; return complement
	add	ax,1		; add one for correct negative number
frret:	pop	ds
	mov	sp,bp
	pop	bp
	ret

_far_read	ENDP

_zopen	PROC NEAR
	push	bp
	mov	bp,sp
	push	ds
	mov	ax,[bp+6]	; mode
	mov	ah,3dH		; Open Handle
	mov	dx,[bp+4]	; path
	int	21H		; do it
	jnc	zoret		; jump if won
	not	ax		; return will be negative...
	add	ax,1		; add one for correct negative number
zoret:	pop	ds
	mov	sp,bp
	pop	bp
	ret

_zopen	ENDP

_zusrfont PROC NEAR
	push	bp
	mov	bp,sp
	push	bp
	push	es
	push	ds
	pop	es
	mov	bp,[bp+4]
	mov	ah,11H
	mov	al,20H
	int	10H
	pop	es
	pop	bp
	mov	sp,bp
	pop	bp
	ret
_zusrfont	ENDP

_zdumpfont PROC	NEAR
	push	bp
	mov	bp,sp
	push	bp
	push	es
	push	ds
	pop	es
	mov	bp,[bp+4]
	mov	ah,11H
	mov	al,21H
        mov	cx,8H
	mov	bl,2
	int	10H
	pop	es
	pop	bp
	mov	sp,bp
	pop	bp
	ret

_zdumpfont	ENDP

_zclose PROC	NEAR
	push	bp
	mov	bp,sp
	mov	ah,3eH
	mov	bx,[bp+4]
	int	21H
	jc	zclret
	mov	ax,0
zclret:	mov	sp,bp
	pop	bp
	ret

_zclose	ENDP

_zcreat	PROC	NEAR

	push	bp
	mov	bp,sp
	push	ds
	mov	ah,3cH
	mov	cx,0		; unrestricted read/write
	mov	dx,[bp+4]
	int	21H
	jnc	zcret
	not	ax
	add	ax,1		; add one for correct negative number
zcret:	pop	ds
	mov	sp,bp
	pop	bp
	ret

_zcreat	ENDP

_crterr	PROC	NEAR
	sti		; re-enable interrupts
	push	bp	; segment address of device header?
	mov	bp,sp	; new base
	push	di
	mov	bx,_data
	mov	es,bx	; we're copying here...
	mov	ds,[bp]	; we'll hope this works
	mov	di,offset _cridevi
	mov	cx,9
	rep	movsw	; copy stuff into cridevi
	mov	bx,_data
	mov	ds,bx	; real data segment, for calling C code
	pop	di	; first arg (error code)
	push	di
	push	ax	; second arg (disk error code)
	mov	ax,offset _cridevi	; device header
	push	ax
	call	_do_error
	add	sp,6		; flush args
ceret:	xor	ah,ah		; clear ah, for fun
	mov	tret,ax		; for later
	mov	sp,bp
	pop	bp
	add	sp,6		; flush return to DOS
	pop	ax		; restore registers
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	bp
	pop	ds
	pop	es
	push	bp
	mov	bp,sp
	push	ax
	push	bx
	mov	ax,tret		; abort or retry?
	mov	bx,[bp+2]	; return address in user code
	cmp	ax,0
	je	cert1
	sub	bx,2		; this is retry, so back up return
	mov	[bp+2],bx
	and	WORD PTR [bp+6],0fffeH
;
; make sure carry not set
;
	jmp	short cert2
cert1:	or	WORD PTR [bp+6],1	; make sure carry set
cert2:	and	WORD PTR [bp+6],0fbffH	; clear direction flag
	pop	bx
	pop	ax
	mov	sp,bp
	pop	bp
	iret

_crterr	ENDP

_TEXT	ENDS
END

           Page  80,132
           Title Trivia - A Graphics Blit/Compression Software Package

;===========================================================================;
;                       'Trivia' project source code                        ;
;                                                                           ;
;  Compression and graphics routines for MCGA, VGA, EGA, and CGA graphics   ;
;                                                                           ;
;                              by John Fachini                              ;
;                      Inside Out Software Incorporated                     ;
;                      For exclusive use by Infocom, Inc.                   ;
;                                                                           ;
;                           Last modified:   May 12, 1989                   ;
;                           Version:         1.11                           ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                           Project specifications:                         ;
;                                                                           ;
; Graphics modes supported:         CGA   640 x 200   2 color               ;
;                                   EGA   640 x 200  16 color               ;
;                                   VGA   320 x 200 256 color               ;
;                                   MCGA  320 x 200 256 color               ;
;                                                                           ;
; Entry points:                                                             ;
;                                                                           ;
;      void cdecl disp_pic_f(x,y,width,height,rx,by,handle,transparent)     ;
;      unsigned int x,y;            /* upper left corner of blit region */  ;
;      unsigned int width,height;   /* width, height of graphics image */   ;
;      unsigned int rx,by;          /* lower right point of blit region */  ;
;      unsigned int handle;         /* file handle of open data file */     ;
;      unsigned char transparent;   /* Transparent color (0xff if none)     ;
;                                                                           ;
;      void cdecl disp_pic_b(x,y,width,height,rx,by,bptr,transparent)       ;
;      unsigned int x,y;            /* upper left corner of blit region */  ;
;      unsigned int width,height;   /* width, height of graphics image */   ;
;      unsigned int rx,by;          /* lower right point of blit region */  ;
;      unsigned char far *bptr;     /* 32 bit address of pre-loaded image */;
;      unsigned char transparent;   /* Transparent color (0xff if none)     ;
;                                                                           ;
; Global variables available at run-time:                                   ;
;                                                                           ;
;      void far *Hash_buff;         /* 12K LZ hash landing area */          :
;      void far *Pic_buff;          /* available buffer pre-allocated */    ;
;      unsigned int Pic_buff_size;  /* size in paragraphs of Pic_buff */    ;
;      unsigned char Display;       /* Display mode (1, 2, or 4) */         ;
;                                                                           ;
; The mission:                                                              ;
;                                                                           ;
;      Blit a compressed image from buffer or file into the indicated       ;
;      screen region, applying transparent color and clipping to the lower  ;
;      right bounds passed in.                                              ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;           Assembled by the Microsoft Macro Assembler version 5.1          :
;                           Options: /V /W2 /Z /Mx                          ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                              Revision History:                            ;
;                                                                           ;
; Version 1.00   -   Initial working code.                                  ;
; Version 1.01   -   Modified to perform blits by line rather than by plane ;
;                    when in EGA 640x200 mode.                              ;
; Version 1.02   -   Uses half of Pic_Buff for EGA buffering instead of     ;
;                    segment B000 to ensure compatibility with clone EGA    ;
;                    cards.                                                 ;
; Version 1.03   -   Blits one line at a time and leaves Pic_buff to full   ;
;                    size.                                                  ;
;                                                                           ;
; Version 1.10   -   Fixed for assembly under Turbo ASM:                    ;
;                       Changed "Extrn C" to just "Extrn"                   ;                        
;                       Changed "Proc C" to just "Proc" in FUNC macro       ;
;                       Add "Publc FuncName" to FUNC macro                  ;
;                       Add "Proc Near" to all functions                    ;
;                        and all matching EndP's                            ;
;                       Make GrafInit be one Proc                           ;
;									    ;
; Version 1.11  -   Made a YTable, GrafSeg, and EGAScratch Public for the   ;
;			scrolling routines				    ;
;									    ;
;***************************************************************************;
;                                                                           ;
;                 First released version to Infocom:    1.03                ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;            "Trivia" - an album by Utopia featuring Todd Rundgren          ;
;              Copyright (C) 1986 Utopia and Passport Records Inc.          ;
;                                                                           ;
;===========================================================================;

           .MODEL  Small,C          ;small memory model, C language

;--------------------------------------------------------------------------
;  C function interface macro
;--------------------------------------------------------------------------
@FUNC      Macro FuncName,FuncParameters
        Public FuncName
FuncName   Proc  FuncParameters                    ;declare public func
           IFNB  <FuncParameters>                    ;for any and all parms
           Irp   @FuncArg,<FuncParameters>           ;state parms to masm
           EndM
           EndIf
           EndM

;--------------------------------------------------------------------------
;  Stack interface macros
;--------------------------------------------------------------------------
@@CheckRegister Macro RegisterToCheck
           IfIdnI  <RegisterToCheck>,<SI>
@SI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DI>
@DI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DS>
@DS_Saved  =     1
           EndIf
           EndM


@LINK      Macro Reg1,Reg2,Reg3
@SI_Saved  =     0                                   ;clear each pushed
@DI_Saved  =     0                                   ;register variable
@DS_Saved  =     0                                   ;this invokation
           IFNB  <Reg1>                              ;check 1 of 3
           @@CheckRegister Reg1
           EndIf
           IFNB  <Reg2>                              ;check 2 of 3
           @@CheckRegister Reg2
           EndIf
           IFNB  <Reg3>                              ;check 3 of 3
           @@CheckRegister Reg3
           EndIf
           if    @SI_Saved                           ;if var says so,
           Push  SI                                  ;push the register
           EndIf
           If    @DI_Saved
           Push  DI
           EndIf
           If    @DS_Saved
           Push  DS
           EndIf
           EndM

@UNLINK    Macro
           If    @DS_Saved                           ;in reverse order as above
           Pop   DS
           EndIf
           If    @DI_Saved
           Pop   DI
           EndIf
           If    @SI_Saved
           Pop   SI
           EndIf
           Ret                                       ;C pops parms, not me
           EndM

;--------------------------------------------------------------------------
;  Graphics card and system variable equates  
;--------------------------------------------------------------------------
USE_CGA    equ   1                  ;'Display' value for CGA 640 x 200
USE_EGA    equ   2                  ;'Display' value for EGA 640 x 200
USE_VGA    equ   4                  ;'Display' value for VGA/MCGA 320 x 200

SEG_CGA    equ   0b800h             ;Segment of CGA video memory
SEG_EGA    equ   0a000h             ;Segment of EGA video memory
SEG_VGA    equ   0a000h             ;Segment of VGA video memory

EGA_SEGOFS equ   1000h              ;paragraphs to skip to second video page

BufUnpack  equ   0                  ;unpack from buffer mode
FileUnpack equ   1                  ;unpack from input file

;--------------------------------------------------------------------------
;  EGA Hardware equates and macros
;--------------------------------------------------------------------------
Plane_Select equ 3c4h               ;Plane select port
Mask_Select  equ 3ceh               ;Mask/Mode select port

;----------------------------------------------------------
; Used by most Out port routines (from the IBM tech-ref)
;----------------------------------------------------------
@OutDX     Macro
           Out   DX,AL
           Inc   DX
           Mov   AL,AH
           Out   DX,AL
           EndM

;--------------------------------------------------------------------------
; Select AH planes as write-able.  Bits 0 - 3 correspond to planes 0 - 3
;--------------------------------------------------------------------------
@WritePlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,2
           Mov   DX,Plane_Select
           @OutDX
           EndM

;-----------------------------------------------------------
; Enable a plane for reading: AH contains plane # (0 - 3)
;-----------------------------------------------------------
@ReadPlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,4
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------------------
; Enable writes to bits according to mask in AH (set bits are enabled)
;-------------------------------------------------------------------------
@WriteMask Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,8
           Mov   DX,Mask_Select
           @OutDX
           EndM

;----------------------------------------------------------
; Set a write mode given mode # in AH
;----------------------------------------------------------
@WriteMode Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,3
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------
; Set EGA graphics to normal write operations
;-------------------------------------------------------------
@NormalMode Macro
           @WriteMode 0
           EndM

;----------------------------------------------------------------------
; Reset the state of the EGA card: all planes, all bits enabled.
;----------------------------------------------------------------------
@ResetEGA  Macro
           @NormalMode
           @WritePlane 0fh
           @WriteMask 0ffh
           EndM

;--------------------------------------------------------------------------
; SetALPixel - set plane layout at ES:DI as bits in lo nibble of AL
;              All registers preserved.
;--------------------------------------------------------------------------
@SetALPixel Macro
           Local P1Check,P2Check,P3Check,SetExit
           Not   DL                 ;convert to one clear bit
           And   ES:[DI    ],DL     ;clear all 4 bit planes by default
           And   ES:[DI+ 80],DL     ;2 of 4
           And   ES:[DI+160],DL     ;3 of 4
           And   ES:[DI+240],DL     ;4 of 4
           Not   DL                 ;reset the bit mask
           Test  AL,1               ;plane 0 need setting?
           Je    P1Check            ;no, check plane 1
           Or    ES:[DI],DL         ;set it
P1Check:
           Test  AL,2               ;plane 1 need setting?
           Je    P2Check            ;no, check plane 2
           Or    ES:[DI+80],DL      ;set it
P2Check:
           Test  AL,4               ;plane 2 need setting?
           Je    P3Check            ;no, check plane 3
           Or    ES:[DI+160],DL     ;set it
P3Check:
           Test  AL,8               ;plane 3 need setting?
           Je    SetExit            ;done
           Or    ES:[DI+240],DL     ;set it
SetExit:
           EndM
           
;--------------------------------------------------------------------------
;  MS-DOS macros and equates for use with the LZ decompression
;--------------------------------------------------------------------------
@Mov32     Macro Dest32,Src32
           Mov   AX,Word Ptr Src32
           Mov   Word Ptr Dest32,AX
           Mov   AX,Word Ptr Src32+2
           Mov   Word Ptr Dest32+2,AX
           EndM

@Normalize Macro Ptr32
           Mov   AX,Word Ptr Ptr32  ;offset in 32 bit field
           Mov   CL,4               ;shift factor
           Shr   AX,CL              ;get rid of lo nibble, shift other 12 down
           And   AX,0fffh           ;for neatness sake
           Add   Word Ptr Ptr32+2,AX ;add in the remnants of the oversized ofs
           And   Word Ptr Ptr32,0fh ;and force the offset in range 00..0f
           EndM

@Dos_Int   Macro CmdCode
           Mov   AH,CmdCode
           Int   21h
           EndM

@FRead     Macro Handle,ReadLength
           IfNB  <Handle>
                 IfDifI <BX>,<Handle>
                 Mov   BX,Handle
                 EndIf
           EndIf
           IfNB <ReadLength>
                 IfDifI <CX>,<ReadLength>
                 Mov   CX,ReadLength
                 EndIf
           EndIf
           @Dos_Int 3fh
           EndM

;--------------------------------------------------------------------------
; LZ decompression constants
;--------------------------------------------------------------------------
Clr_Token  equ   256                ;clear hash table token
Eof_Token  equ   257                ;end of compressed stream token
FF_Token   equ   258                ;first free hash entry token

;--------------------------------------------------------------------------
;  LZ hash table structure 
;--------------------------------------------------------------------------
HashStruct Struc
Next       dw    ?
Char       db    ?
HashStruct EndS

;--------------------------------------------------------------------------
; LZ macros for much improved decompression performance.  These were
; subroutines once but the routine proved too slow on 4.77 MHz machines.
; Also note: the register assumptions during the execution of the LZ
; decompression loop are minimal:
;          DS : C's data segment
; That's it.
; Wake up J.D.!
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; @Index: Return BX * 3 (3 = sizeof(HashStruc))
;--------------------------------------------------------------------------
@Index     Macro
           Push  AX                 ;preserve AX
           Mov   AX,BX              ;temp storage
           Shl   BX,1               ;BX * 2
           Add   BX,AX              ;add makes it *3
           Pop   AX                 ;restore AX
           EndM

;--------------------------------------------------------------------------
; @Add_Code: Add a code to the hash table.
;            On exit, AX, BX, ES, and DI are trashed
;--------------------------------------------------------------------------
@Add_Code  Macro
           Mov   BX,FreeCode        ;BX = next free code from local storage
           @Index                   ;build index into hash table
           Les   DI,Hashbuff        ;12K hash area address
           Add   DI,BX              ;add in the hash index
           Mov   AL,K               ;setup for the move
           Mov   ES:[DI].Char,AL    ;save the char in the hash rec
           Mov   AX,OldCode         ;linkage
           Mov   ES:[DI].Next,AX    ;as next ptr
           Inc   FreeCode           ;next one is free
           EndM

;--------------------------------------------------------------------------
; @Init_Table: setup local vars for table initialization
;--------------------------------------------------------------------------
@Init_Table Macro
           Mov   NBits,9            ;Starting with 9 bit codes
           Mov   MaxCode,512        ;10 0000 0000 b
           Mov   FreeCode,FF_Token  ;Reset next code free entry
           EndM

;--------------------------------------------------------------------------
; @CGA_Write: Store a block of 8 pixels into display memory.  Trashes DI,CX
;	      Counts bytes written, watches for picture width to be hit,
;	      and advances to the next line.
;-------------------------------------------------------------------------
@CGA_Write Macro
	Local	CGAW_2,CGAW_1,CGAW_0,CGAW_3,CGAW_4,CGAW_5,CGAW_6
	Cmp	CGA_Shift,0		;Faster if we're byte-aligned
	 Jne	CGAW_0
	Les	DI,Tempbuff
	Dec	CGA_Left
	 Jz	CGAW_4			;Jump if last byte on line
	StoSB
	Inc	Word Ptr Tempbuff
	Jmp	CGAW_2
CGAW_4:	Mov	AH,ES:[DI]  		;Pick up screen byte
	Mov	DI,CGA_Trail		; And mask off the unused part
	And	AH,CGA_Masks[DI]
	Or	AL,AH
	Mov	DI,Tempbuff
	StoSB				;Write out the last one
	Jmp	Short CGAW_3		;And move to the next line

CGAW_0:	Mov	CL,CGA_Shift		;Current stuff ends up low in AL;
	Ror	AX,CL			;Stuff for next byte high in AH
	Mov	DI,CGA_Shift
	And	AL,CGA_Masks[DI]	;Clear the high part in AL
	Or	AL,CGA_Temp		;Combine with what we had saved
	And	AH,CGA_Omasks[DI]	;Clear the low part in AH
	Mov	CGA_Temp,AH		;Save for next time
	Les	DI,Tempbuff
	Dec	CGA_Left		;Check for end of line
	 Jz	CGAW_5			;Yes, extra hair
	StoSB	      			; Store the byte (normal case)
	Inc	Word Ptr Tempbuff
	Jmp	Short CGAW_2
CGAW_5:	Cmp	CGA_Trail,0
	 Jge	CGAW_6
	StoSB				; Store a byte
	Inc	Word Ptr Tempbuff
	Mov	AL,ES:[DI]		; Pick up next screen byte
	Mov	DI,CGA_Trail
	Neg	DI
	And	AL,CGA_Masks[DI]
	Or	AL,CGA_Temp
	Mov	DI,Tempbuff
	StoSB
	Jmp	Short CGAW_3
CGAW_6:	Mov	AH,ES:[DI]		;Yes, pick up the next byte from the screen
	Mov	DI,CGA_Trail		;So we can dump our partial byte
	And	AH,CGA_Masks[DI]
	Or	AH,CGA_Temp
	Or	AL,AH
	Mov	DI,Tempbuff
	StoSB
CGAW_3:	Inc	CGA_Curline		;Current line
	Mov	DI,CGA_Curline
	Shl	DI,1
	Mov	CX,Ytable[DI] 		;Beginning of display memory
	Add	CX,CGALStart		;Beginning of this picture
	Mov	Tempbuff,CX
	Mov	CX,CGA_Len
	Mov	CGA_Left,CX
	Cmp	CGA_Shift,0
	 Je	CGAW_2
	Mov	DI,Tempbuff
	Mov	AL,ES:[DI]		;Pick up the first byte
	Mov	DI,CGA_Shift		;And save the high part
;	Ror	AX,CL
;	Mov	DI,CGA_Shift
	And	AL,CGA_Omasks[DI]
	Mov	CGA_Temp,AL
CGAW_2:
	EndM	

;--------------------------------------------------------------------------
; @Write_Char: Store the decompressed byte in AL into the dest buffer.
;              On exit, DI is trashed.  The modification made to this
;              routine counts the bytes written, watches for the
;              calculated byte limit to be hit and the graphics blit
;              is forced.  Normally the graphics code (noted below)
;              would not appear in the macro.
;--------------------------------------------------------------------------
@Write_Char Macro
           Local Write_Char_1,Write_Char_2
           Les   DI,Tempbuff        ;32 bit dest for the byte
           StoSB                    ;write the new byte into the buffer
           Inc   Word Ptr Tempbuff  ;next offset
; Note--we never need to normalize Tempbuff, because it can never overflow
; 64K, and we don't compare different copies of it
;           Cmp   DI,16              ;time to normalize the 32 bit pointer?
;           Jne   Write_Char_1       ;no
;           Inc   Word Ptr Tempbuff+2  ;increment the segment pointer
;           Mov   Word Ptr Tempbuff,0  ;with offset 0
Write_Char_1:
           Inc   ByteCount          ;another byte's been written
           Mov   AX,ByteCount
           Cmp   AX,PicLimit        ;time to do the blit?
           Jne   Write_Char_2       ;nope
           Call  Blit               ;go for it
Write_Char_2:
           EndM

;--------------------------------------------------------------------------
; @Read_Code: process a code from the input stream
;--------------------------------------------------------------------------
@Read_Code Macro
           Local Read_Code_0,Read_Code_1,Read_Code_2,Read_Code_3,Read_Code_4,read_code_98,read_code_99
           Mov   AX,BitOffset       ;current bit offset
           Add   AX,NBits           ;add in current width
           Xchg  BitOffset,AX       ;swap em
           Mov   CX,8               ;Find byte/bit offset
           Xor   DX,DX              ;clear DX (MSW for div)
           Div   CX                 ;AX = result, DX remainder
           Cmp   AX,BUFSIZE-3       ;Nearing buffer full?
           Jl    Read_Code_0        ;no
           Push  DX                 ;save bits remaining calc
           Add   DX,NBits           ;Add bits to bits
           Mov   BitOffset,DX       ;new bit offset
           Mov   CX,BUFSIZE         ;buffer size
           Push  AX                 ;Save byte offset
           Sub   CX,AX              ;bytes left
           Push  DS
           Pop   ES                 ;ES,DS both C's DS
           Mov   SI,Offset Dgroup:Buffer
           Mov   DI,SI              ;base pointers for both
           Add   SI,AX              ;source skips ahead
           Rep   MovSB              ;'slide' the buffer
           Pop   CX                 ;pop byte offset (# of bytes to refill)
           Cmp   PickUnpack,FileUnpack ;use file?
           Je    Read_Code_3        ;yup
           Push  DS                 ;save C's DS
           Lds   SI,InputBuff       ;input buffer points to mem source
           Rep   MovSB              ;do 'read'
           Pop   DS                 ;restore me
           Mov   Word Ptr InputBuff,SI ;update to the new source offset
           @Normalize InputBuff     ;and normalize it
           Jmp   Short Read_Code_4  ;continue
Read_Code_3:
           Mov   DX,DI              ;pointer to read's dest
           @Fread FileHandle        ;gimmie more
Read_Code_4:
           Pop   DX                 ;get bit offset back from TOS
           Xor   AX,AX              ;read at start of buffer again (offset 0)
Read_Code_0:
           Mov   SI,Offset Dgroup:Buffer
           Add   SI,AX              ;offset into read buf
           LodSW                    ;get 'next' from record
           Mov   BX,AX              ;save it here
           LodSB                    ;get 'char'
           Mov   CX,DX              ;setup loop usage
           Jcxz  Read_Code_2        ;no need to do shifting
Read_Code_1:
           Shr   AL,1               ;drop lo bit into carry
           Rcr   BX,1               ;catch it here
           Loop  Read_Code_1        ;let CX say when to stop
Read_Code_2:
           Mov   AX,BX              ;what's left here we need too
           Mov   BX,NBits           ;bit count
           Sub   BX,9               ;generate index 0..3 inclusive
           Shl   BX,1               ;convert to word index
           And   AX,Masks[BX]       ;leave 9,10,11, or 12 bits
           EndM


;--------------------------------------------------------------------------
; Standardize entry macro for the "Trivia" routine
;--------------------------------------------------------------------------
@StandardEntry Macro
           Mov   AX,X0              ;upper left X in AX
           Mov   BX,Y0              ;upper left Y in BX
           Mov   CX,X1              ;lower right X in CX
           Mov   DX,Y1              ;lower right Y in CX
           Mov   SI,W               ;picture width in SI
           Mov   DI,H               ;picture height in DI
           EndM


;************************ The real stuff starts here *************************

           .Data
;--------------------------------------------------------------------------
;  External variable declarations
;--------------------------------------------------------------------------
           Extrn Hash_buff        : DWord          ;pointer to 12K hash area
           Extrn Pic_buff         : DWord          ;pointer to scratch area
           Extrn Pic_buff_size    : Word           ;size in para of Pic_buff
           Extrn Display          : Byte           ;display type field

	   Public YTable
	   Public GrafSeg
	   Public EGAScratch

BUFSIZE    equ   1024               ;Must be at least 1K and an even number
;--------------------------------------------------------------------------
;  "Trivia"'s kept variable space (sorry so much...)
;--------------------------------------------------------------------------
Buffer     db    BUFSIZE dup (?)    ;landing area for buffer input
EGAScratch db    80 * 4 dup (?)     ;bytes per line times 4 bit planes
Masks      dw    0000000111111111b  ;LZ bit masks (9 bits)
           dw    0000001111111111b  ;10 bits
           dw    0000011111111111b  ;11 bits
           dw    0000111111111111b  ;12 bits
BitOffset  dw    ?                  ;current bit offset
CurCode    dw    ?                  ;current code
OldCode    dw    ?                  ;last code processed
InCode     dw    ?                  ;code in use
FreeCode   dw    ?                  ;next free code for hash table entry
StackCount dw    ?                  ;count of pushed words
MaxCode    dw    ?                  ;max usable code this pass
NBits      dw    ?                  ;number of bits in current code
ByteCount  dw    ?                  ;number of bytes written since last blit
FinalChar  db    ?                  ;last unpacked
K          db    ?                  ;current unpacked

           Even
;--------------------------------------------------------------------------
; Graphics driver variable space
;--------------------------------------------------------------------------
GrafSeg    dw    0                  ;active graphics segment
Picbuff    dd    0                  ;32 bit scratch pointer to Pic_buff
Tempbuff   dd    0                  ;32 bit scratch pointer reset per blit
Hashbuff   dd    0                  ;32 bit scratch pointer to Hash_buff
CGALStart  dw	 0		    ;Offset from line start to picture start
CGA_Left   dw	 0		    ;Bytes left on this line
CGA_Len	   dw    0		    ;Bytes on line
CGA_Curline dw	 0
CGA_Shift  dw    0		    ;Shift byte right by this much
CGA_Trail  dw    0
CGA_Temp   db    0		    ;Current byte we're working on
CGA_Masks  db    0
	   db    01111111b
	   db    00111111b
	   db    00011111b
	   db    00001111b
	   db    00000111b
	   db    00000011b
	   db    00000001b
CGA_Omasks db    0
	   db    10000000b
	   db    11000000b
	   db    11100000b
	   db    11110000b
	   db    11111000b
	   db    11111100b
	   db    11111110b
BitTable   db    10000000b          ;mask for bit 0 set
           db    01000000b          ;mask for bit 1 set
           db    00100000b          ;and so on
           db    00010000b
           db    00001000b
           db    00000100b
           db    00000010b
           db    00000001b
YTable     dw    200 dup (?)        ;200 lines in each display mode
CoordX0    dw    ?                  ;upper left X coord this call
CoordY0    dw    ?                  ;upper left Y coord this call
CoordX1    dw    ?                  ;lower right X coord this call
CoordY1    dw    ?                  ;lower right Y coord this call
PicWidth   dw    ?                  ;image width in pixels (1 based)
PicHeight  dw    ?                  ;image height in pixels (1 based)
PicLines   dw    ?                  ;number of lines Picbuff will hold
PicLimit   dw    ?                  ;number of bytes to unpack before blit
CurrentY   dw    ?                  ;last referenced Y co-ord during blit
LineCount  dw    ?                  ;line counter during blit operation
TrueWidth  dw    ?                  ;byte width of line with clipping applied
FileHandle dw    ?                  ;file handle in use
InputBuff  dd    ?                  ;input buffer in leiu of file handle
EGACount   dw    ?                  ;number of bytes to blit per line (EGA)
TrueOffset dw    ?                  ;calculated starting byte offset in EGA
TransColor db    ?                  ;transparent color, this call
StartMask  db    ?                  ;bit mask (CGA) for starting bit
PickUnpack db    ?                  ;unpack method (buffer or disk)

;************************** And finally... the code *************************

           .Code

;--------------------------------------------------------------------------
; Trivia:  main entry point for C callable routines.
; Input:   AX         - upper left X of dest region
;          BX         - upper left Y of dest region
;          CX         - lower right X of dest region
;          DX         - lower right X of dest region
;          SI         - picture width (1 based)
;          DI         - picture height (1 based)
;          TransColor - set to transparent color passed in from C
;          PickUnpack - Set to 'BufUnpack' or 'FileUnpack' constant
;                       on BufUnpack :
;                              InputBuff: normalized pointer to data
;                       on FileUîpack :
;                              FileHandle: input file's handle
;--------------------------------------------------------------------------
Trivia     Proc  Near

           Mov   CoordX0,AX         ;set the public access versions of vars
           Mov   CoordY0,BX
           Mov   CoordX1,CX
           Mov   CoordY1,DX
           Mov   PicWidth,SI
           Mov   PicHeight,DI
           Mov   CurrentY,BX        ;init. to top of screen buffer
;--------------------------------------------------------------------------
; Set up the local versions of Pic_buff and Hash_buff
;--------------------------------------------------------------------------
Trivia_0:
           @Mov32 PicBuff,Pic_Buff
           @Mov32 HashBuff,Hash_Buff
           @Normalize PicBuff
           @Normalize Hashbuff
           Call  GrafInit           ;init the graphics variables now
;--------------------------------------------------------------------------
; Initialize the LZ decompression variables
;--------------------------------------------------------------------------
           @Init_Table
           Mov   StackCount,0       ;word count of pushed items
           Mov   BitOffset,0        ;no bits so far
           Mov   ByteCount,0        ;no bytes written yet either
           @Mov32  TempBuff,PicBuff ;working copy of the picbuff
;--------------------------------------------------------------------------
; Initialize the buffer space by reading from input (either buffer or disk)
;--------------------------------------------------------------------------
           Cmp   PickUnpack,FileUnpack ;use files?
           Je    Trivia_F0          ;yup
           Push  DS
           Pop   ES                 ;ES == C's DS
           Lds   SI,InputBuff       ;DS:SI start of input buffer
           Mov   DI,Offset Dgroup:Buffer ;landing area is ES:DI
           Mov   CX,BUFSIZE/2       ;buffer size in words
           Rep   MovSW              ;fill buffer
           Push  SS
           Pop   DS                 ;DS back to 'normal'
           Mov   Word Ptr InputBuff,SI ;update the offset value
           @Normalize InputBuff     ;and normalize it (being consistent...)
           Jmp   Trivia_LZ0   ;jump to the decompress loop
;--------------------------------------------------------------------------
; Load the now un-initialize input buffer via the file handle
;--------------------------------------------------------------------------
Trivia_F0:
           Mov   DX,Offset Dgroup:Buffer ;DS:DX is dest buffer for DOS
           @FRead FileHandle,BUFSIZE     ;load from disk
	   Cmp	 TransColor,0ffh	 ;check for no transparency
	    Je	 Trivia_F1
	    Jmp	 Trivia_LZ0		 ;Has transparency, no speedup
Trivia_F1: Cmp	 Display,USE_VGA
	    Jne	 Trivia_F2		 ;No hair needed for mcga mode
	    Jmp	 Trivia_LZ0
Trivia_F2: Cmp	 Display,USE_CGA
	    Je	 Trivia_CGA		 ;EGA case with no transparency
	   Jmp	 Trivia_LZ0
;--------------------------------------------------------------------------
; Unpack CGA stuff with no transparency
; This is stored 8 bits/byte, with a 1 bit meaning white.  Each line starts
; on a byte boundary.
;--------------------------------------------------------------------------
Trivia_CGA:
	Mov	BX,CurrentY
	Mov	CGA_Curline,BX		;Line we're now on
	Mov	DI,BX
	Shl	DI,1
	Mov	DI,YTable[DI]		;Beginning of first line
	Mov	AX,CoordX0
	Mov	CL,3
	Shr	AX,CL
	Mov	CGALStart,AX
	Add	DI,AX
	Mov	Word Ptr Tempbuff,DI	;Use the graphics segment
	Mov	AX,CoordX0		;First pixel
	And	AX,7			;How many bits to skip in first screen byte
	Mov	CGA_Shift,AX
	Mov	AX,PicWidth
	Mov	CL,3
	Shr	AX,CL	   		;Get width in bytes
	Mov	CGA_Left,AX
	Mov	CGA_Len,AX
	Mov	AX,PicWidth
	And	AX,7			;Number of bits used in last screen byte
	 Je	C_LZ5
	Inc	CGA_Left
	Inc	CGA_Len
C_LZ5:
	Cmp	CGA_Shift,0
	 Jne	C_LZ6
	Mov	CGA_Trail,AX
	Jmp	Short C_LZ4
C_LZ6:	Mov	AX,CoordX0
	Add	AX,PicWidth
	And	AX,7
	Mov	BX,PicWidth
	And	BX,7	   		;Number of bits supplied by last byte
	Cmp	AX,BX
	 Jl	C_LZ7
	Mov	CGA_Trail,AX
	Jmp	Short C_LZ4
C_LZ7:	Neg	AX
	Mov	CGA_Trail,AX
C_LZ4:	Mov	DI,GrafSeg
	Mov	Word Ptr Tempbuff+2,DI
	Mov	CGA_Temp,0
	Cmp	CGA_Shift,0
	 Je	C_LZ0
	Les	DI,Tempbuff
	Mov	AL,ES:[DI]
	Mov	Cl,8
	Sub	CL,CGA_Shift
	Shr	AL,CL
	Shl	AL,CL
	Mov	CGA_Temp,AL		;Initialize Temp
C_LZ0:	@Read_Code			;Get next code
	Cmp	AX,Eof_Token		;done?
	Jne	CNot_EOF		;no, do something with it
;	Call	CGA_Blit		;yes, do last blit
	Ret

CNot_EOF:
	Cmp	AX,Clr_Token		;Clear hash table?
	 Je	CNot_EOF_1
	Jmp	CGA_Process
CNot_EOF_1:
	@Init_Table
	@Read_Code
	Mov	CurCode,AX
	Mov	OldCode,AX
	Mov	K,AL
	Mov	FinalChar,AL
	@CGA_Write
	Jmp	C_LZ0
CGA_Process:
	Mov	CurCode,AX
	Mov	InCode,AX
	Cmp	AX,FreeCode
	Jl	CTabled
	Mov	AX,OldCode
	Mov	CurCode,AX
	Mov	AL,FinalChar
	Push	AX
	Inc	StackCount
CTabled:
	Cmp	CurCode,0ffh
	 Jle	CGA_Char
	Mov	BX,CurCode
	@Index
	Les	DI,Hashbuff
	Add	DI,BX
	Mov	AL,ES:[DI].Char
	Push	AX
	Inc	StackCount
	Mov	AX,ES:[DI].Next
	Mov	CurCode,AX
	Jmp	Short CTabled
CGA_Char:
	Mov	AX,CurCode
	Mov	FinalChar,AL
	Mov	K,AL
	Push	AX
	Inc	StackCount
	Mov	CX,StackCount
CGA_Loop:
	Pop	AX
	Push	CX
	@CGA_Write
	Pop	CX
	Loop	CGA_Frob
	 Jmp	Short CGA_Clear
CGA_Frob:
	Jmp	CGA_Loop
CGA_Clear:
	Mov	StackCount,CX
	@Add_Code
	Mov	AX,InCode
	Mov	OldCode,AX
	Mov	BX,FreeCode
	Cmp	BX,MaxCode
	 Jl	CGA_No_Max
	Cmp	NBits,12
	 Je	CGA_No_Max
	Inc	NBits
	Shl	MaxCode,1
CGA_No_Max:
	Jmp	C_LZ0

;--------------------------------------------------------------------------
; Unpack loop entry point 
;--------------------------------------------------------------------------
Trivia_LZ0:
           @Read_Code               ;get next code from input stream
           Cmp   AX,Eof_Token       ;all done?
           Jne   Not_EOF            ;nope
;--------------------------------------------------------------------------
; We're done, blit what's left and return to C
;--------------------------------------------------------------------------
           Call  Blit               ;finish up with what's left
           Ret                      ;life goes on

Not_EOF:
           Cmp   AX,Clr_Token       ;smash the hash table?
           Je    Not_EOF_1          ;yes sir
           Jmp   Process_Code       ;no, AX is a real compressed code
Not_EOF_1:
           @Init_Table              ;clear hash table
           @Read_Code               ;reload if needed, get next code
           Mov   CurCode,AX         ;current code
           Mov   OldCode,AX         ;same as for now
           Mov   K,AL               ;lo byte
           Mov   FinalChar,AL       ;lo byte
           @Write_Char              ;send the code back
           Jmp   Trivia_LZ0         ;and back for more
Process_Code:
           Mov   CurCode,AX         ;save the latest passed in
           Mov   InCode,AX          ;here too
           Cmp   AX,FreeCode        ;is it in the hash table yet?
           Jl    Tabled_Code        ;sure is
           Mov   AX,OldCode         ;gimmie this back
           Mov   CurCode,AX         ;curcode = oldcode
           Mov   AL,FinalChar       ;reload this too
           Push  AX                 ;save it (here's the stack usage stuff)
           Inc   StackCount         ;one more push has been done
Tabled_Code:
           Cmp   CurCode,0ffh       ;is it a 'char'?
           Jle   Its_A_Char         ;pass out the cigars, it is
           Mov   BX,CurCode         ;need an index so
           @Index                   ;give it
           Les   DI,Hashbuff        ;pointer to base of table
           Add   DI,BX              ;add in base and offset to table
           Mov   AL,ES:[DI].Char    ;grab the suffix
           Push  AX                 ;more of this stuff
           Inc   StackCount         ;stack space dwindles...
           Mov   AX,ES:[DI].Next    ;prefix
           Mov   CurCode,AX         ;our new current code
           Jmp   Short Tabled_Code  ;one more time...
Its_A_Char:
           Mov   AX,CurCode         ;active code
           Mov   FinalChar,AL       ;last char
           Mov   K,AL               ;here too
           Push  AX                 ;stack it up
           Inc   StackCount         ;one last time
           Mov   CX,StackCount      ;ready for the loop
Its_A_Loop:
           Pop   AX                 ;get the next char from TOS
           @Write_Char              ;write it to the output buffer
           Loop  Its_A_Loop         ;until the stack is balanced again
Clear_It:
           Mov   StackCount,CX      ;zero the stackcount
           @Add_Code                ;put code in table
           Mov   AX,InCode          ;in code
           Mov   OldCode,AX         ;is now the oldcode
           Mov   BX,FreeCode        ;next free
           Cmp   BX,MaxCode         ;max yet?
           Jl    No_Max             ;nope
           Cmp   NBits,12           ;run out of bits?
           Je    No_Max             ;stick with 12 'til the clear comes thru
           Inc   NBits              ;next (10,11,12)
           Shl   MaxCode,1          ;give it a bit in both places
No_Max:
           Jmp   Trivia_LZ0         ;back for more

Trivia     Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit: Call appropriate graphics blit function, reset 'ByteCount' and
;       Tempbuff values, and return.
;       On exit, DS and CX are preserved.
;--------------------------------------------------------------------------
Blit       Proc  Near

           Cmp   ByteCount,0        ;need to do this?
           Je    Blit_3             ;no need
           Push  DS                 ;save the
           Push  CX                 ;promised registers
           Mov   AX,ByteCount       ;this check is needed in case of
           Cmp   AX,PicLimit        ;a partially full buffer at the end of
           Je    Blit_00            ;the compression loop
           Xor   DX,DX              ;MSW
           Mov   CX,PicWidth        ;bytes in width
           Div   CX                 ;AX = new line count
           Mov   PicLines,AX        ;new line count this buffer
Blit_00:
           @Mov32  Tempbuff,Picbuff ;reset temp pointer to buffer start
           Mov   ES,GrafSeg         ;load this up by default
           Cmp   Display,USE_VGA    ;VGA/MCGA mode?
           Jne   Blit_0             ;no
           Call  Blit_VGA           ;yes
           Jmp   Short Blit_2       ;skip other tests
Blit_0:
           Cmp   Display,USE_EGA    ;EGA mode?
           Jne   Blit_1             ;sorry
           Call  Blit_EGA           ;go for it
           Jmp   Short Blit_2       ;skip to end
Blit_1:
           Cmp   Display,USE_CGA    ;CGA mode?
           Jne   Blit_2             ;forget it, just do cleanup
           Call  Blit_CGA           ;3rd of 3
Blit_2:
           Pop   CX                 ;back from TOS
           Pop   DS                 ;and NOS
           Mov   ByteCount,0        ;we've used up our bytes
Blit_3:
           @Mov32  Tempbuff,Picbuff ;reset the buffer pointer
           Ret                      ;and go unpack more data
Blit       Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_VGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_VGA   Proc  Near

           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_V0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Ja    Blit_V5            ;yes, time to go
           Mov   DI,BX              ;need the lookup
           Shl   DI,1               ;Ytable is a word table
           Mov   DI,YTable[DI]      ;got it
           Add   DI,CoordX0         ;add in the base X
           Mov   CX,TrueWidth       ;the 'real' line width displayable
           Mov   AH,TransColor      ;transparent color (0..fe)
           Lds   SI,Tempbuff        ;source
           Cmp   AH,0ffh            ;no mask?
           Je    Blit_V3            ;none: use the quick method
Blit_V1:
           LodSB                    ;AL = pixel value
           Cmp   AL,AH              ;write over screen byte?
           Je    Blit_V2            ;no, AL is "transparent"...
           Mov   ES:[DI],AL         ;put the new pixel in
Blit_V2:
           Inc   DI                 ;next byte in video buffer
           Loop  Blit_V1            ;for 'truewidth' pixels
           Jmp   Short Blit_V4      ;skip the easy move code
Blit_V3:
           Rep   MovSB              ;move those pixels
Blit_V4:
           Push  SS                 ;in small model, SS == C's DS
           Pop   DS                 ;so recover it this way
           Mov   AX,PicWidth        ;width of a buffered line in bytes
           Add   Word Ptr Tempbuff,AX ;skip the entire line width
;           @Normalize TempBuff      ;clean it up
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Dec   DX                 ;one less line to do
           Jne   Blit_V0            ;back for more unless zero to do
Blit_V5:
           Ret                      ;done
Blit_VGA   Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_EGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_EGA   Proc  Near
           Cmp   ByteCount,0        ;anything to 'blit'...?
           Je    Blit_E8            ;no, get outta here
           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_E0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Ja    Blit_E8            ;yes, get out quick
	   Cmp	 TransColor,0ffH
	    Je	 EGA_Notr	    ;No transparency, do it faster
           Push  DX                 ;save this (only useful later)
           Push  ES                 ;make DS the video seg
           Pop   DS                 ;and make ES the data seg
           Push  SS                 ;small model
           Pop   ES                 ;there
           Call  CopyEGALine        ;copy line BX from video to buffer
           Call  ApplyEGAData       ;apply the unpacked data to video info
           Call  BlitEGALine        ;and show the new line on the screen
EGA_Next:  Pop   DX                 ;back again
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Dec   DX                 ;one less line to do
           Jne   Blit_E0            ;back for more
Blit_E8:
           @ResetEGA                ;leave the card in normal state
           Ret                      ;done
Blit_EGA   Endp

; For each line, copy the first and last bytes (suitably masked),
; then generate bitplanes in EGAScrath, then do the blt.
EGA_Notr:
	Push	DX
	Push	ES
	Pop	DS
	Push	SS
	Pop	ES		; Set up segment registers funnily
	Push	BX
	Shl	BX,1
	Mov	SI,SS:Ytable[BX]
	Mov	DI,Offset Dgroup:EGAScratch
	Mov	BX,SS:EGACount
	Dec	BX			;Since we're not doing a rep movsb
	Mov	DX,SS:TrueOffset
	Add	SI,DX
	Add	DI,DX
	Xor	AH,AH
EGA_Notr_0:
	@ReadPlane
	Mov	AL,[SI]
	Mov	ES:[DI],AL
	Add	DI,BX			;Move to the end
	Add	SI,BX
	Mov	AL,[SI]
	Mov	ES:[DI],AL
	Add	DI,80
	Sub	DI,BX
	Sub	SI,BX
	Inc	AH
	Cmp	AH,4
	 Jne	EGA_Notr_0
	@ResetEGA
	Pop	BX
;Now have the beginning and end of the line copied from the EGA card.
;Turn the pixels into bitplanes, then do the transfer.
	Push	DS
	Mov	CX,SS:TrueWidth
	Mov	DI,Offset Dgroup:EGAScratch
	Add	DI,SS:TrueOffset
	Mov	DL,SS:StartMask
	Lds	SI,SS:Tempbuff
EGA_Notr_1:
	LodSB
	@SetALPixel
	Shr	DL,1
	 Jnc	EGA_Notr_2
	Mov	DL,80h
	Inc	DI
EGA_Notr_2:
	Loop	EGA_Notr_1
	Push	SS
	Pop	DS
	Mov	AX,PicWidth
	Add	Word Ptr Tempbuff,AX
;	 @Normalize TempBuff
	Pop	DS
	Call	BlitEGALine
	Jmp	EGA_Next

;--------------------------------------------------------------------------
; CopyEGALine: read line BX from the video card and copy it into
;              EGAScratch so that the plane data aligns with the
;              +0,+80,+160,+240 offsets into the buffer.
; On entry, DS video segment, ES is C's DS, BX is line number.
; On exit,  DS, ES, and BX must be preserved.
;--------------------------------------------------------------------------
           Even
CopyEGALine  Proc Near

           Push  BX                 ;save me
           Shl   BX,1               ;*2
           Mov   SI,SS:YTable[BX]   ;starting position
           Mov   DI,Offset Dgroup:EGAScratch ;base internal line buffer
           Mov   BX,SS:EGACount     ;line width for looping
           Mov   DX,SS:TrueOffset   ;starting offsets from lines
           Add   SI,DX              ;add in the offset
           Add   DI,DX              ;for both buffers
           Xor   AH,AH              ;start with plane zero
CopyEGALine_0:
           @ReadPlane               ;read plane AH (0..3)
           Mov   AL,[SI]            ;latch in new state
           Mov   CX,BX              ;number of bytes to move
           Rep   MovSB              ;put it in the buffer
           Add   DI,80              ;skip to next plane
           Sub   DI,BX              ;backup for additional moves
           Sub   SI,BX              ;yea yea, here too
           Inc   AH                 ;next plane
           Cmp   AH,4               ;done yet?
           Jne   CopyEGALine_0      ;yes
           @ResetEGA                ;no, put the card in a nice state
           Pop   BX                 ;in the right order
           Ret                      ;see ya
CopyEGALine Endp

;--------------------------------------------------------------------------
; ApplyEGAData: Take from the TempBuff and apply unpacked bytes to the
;               bit plane formatted data in EGAScratch.
; On entry, DS = video seg, ES = C's DS, BX = current line
; On exit,  DS, ES, BX must be preserved
;--------------------------------------------------------------------------
           Even
ApplyEGAData  Proc Near
           Push  DS                 ;save me
           Mov   CX,SS:TrueWidth    ;the 'real' line width displayable
           Mov   AH,SS:TransColor   ;transparent color (0..fe)
           Mov   DI,Offset Dgroup:EGAScratch ;dest
           Add   DI,SS:TrueOffset   ;adjusted for byte position
           Mov   DL,SS:StartMask    ;starting bit mask value
           Lds   SI,SS:Tempbuff     ;source
	   cmp	 AH,0ffh	    ; are we doing anything transparent?
ApplyEGA_0:
           LodSB                    ;input byte (only lo nibble counts)
           Cmp   AL,AH              ;did we match?
           Je    ApplyEGA_2         ;yes, skip this here pixel
ApplyEGA_1:
           @SetALPixel              ;keep things simple this way
ApplyEGA_2:
           Shr   DL,1               ;slide mask down the bits
           Jnc   ApplyEGA_3         ;no drop off yet
           Mov   DL,80h             ;up to top of next byte
           Inc   DI                 ;and skip to next byte in buffer
ApplyEGA_3:
           Loop  ApplyEGA_0         ;for CX pixels in the buffer
	   Push  SS
	   Pop   DS
	   Mov	 AX,PicWidth
           Add   Word Ptr Tempbuff,AX ;skip the entire line width
;           @Normalize TempBuff      ;clean it up
           Pop   DS                 ;restore video seg as DS (ES never changed)
           Ret                      ;and go back
ApplyEGAData   Endp


;--------------------------------------------------------------------------
; BlitEGALine: Move planed data from EGAScratch onto screen at Y line BX.
; On entry, DS = video segment, ES = C's data segment, BX = dest Y
; On exit,  DS = C's data segment, ES = video segment, BX preserved
;--------------------------------------------------------------------------
           Even
BlitEGALine  Proc Near

           Push  BX                 ;save for return to caller
           Push  DS                 ;need to swap these here segment registers
           Push  ES                 ;this should be familiar
           Pop   DS                 ;by now
           Pop   ES                 ;xchg ds,es
           Mov   DI,BX              ;dest Y
           Shl   DI,1               ;for lookup in table
           Mov   DI,YTable[DI]      ;base Y
           Mov   SI,Offset Dgroup:EGAScratch ;start of data (p0,p1,p2,p3)
           Mov   BX,TrueOffset      ;keep this around
           Add   DI,BX              ;offset to starting X byte
           Add   SI,BX              ;compensate here too
           Mov   BX,EGACount        ;number of bytes to move
           Mov   AH,1               ;write plane selector
EGALine_0:
           @WritePlane              ;enable the card
           Mov   AL,ES:[DI]         ;latch the new state in
           Mov   CX,BX              ;# of bytes to move
           Rep   MovSB              ;move data onto screen
           Shl   AH,1               ;next plane
           Add   SI,80              ;add in bytes per line; skip to next plane
           Sub   SI,BX              ;compensate for moved data
           Sub   DI,BX              ;one more
           Cmp   AH,10h             ;video seg hit end yet?
           Jne   EGALine_0          ;not yet
           Pop   BX                 ;get BX back from TOS
           Ret                      ;and go back
BlitEGALine EndP

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_CGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_CGA   Proc  Near
           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_C0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Jna   Blit_C0x	    ;nope, doing just fine
           Jmp	 Blit_C6	    ;yes, time to go
Blit_C0x:
           Push  DX                 ;save line counter at TOS
           Mov   DI,BX              ;need the lookup
           Shl   DI,1               ;Ytable is a word table
           Mov   DI,YTable[DI]      ;got it
           Mov   AX,CoordX0         ;starting X
           Mov   CL,3               ;divide by 8
           Shr   AX,CL              ;to find starting byte (bit per pixel)
           Add   DI,AX              ;mix it in
           Mov   CX,TrueWidth       ;the 'real' line width displayable
           Mov   AH,TransColor      ;transparent 'bit'
           Mov   DL,StartMask       ;starting mask (single bit)
           Lds   SI,Tempbuff        ;source
           Cmp   AH,0ffh            ;transparent off?
           Je    Blit_C1nt	    ; not transparent color, so don't look
Blit_C1:
           LodSB                    ;AL = pixel value (0 or 1)
           Cmp   AL,AH              ;write over screen byte?
           Je    Blit_C4            ;no, AL is "transparent"...
Blit_C2:
           And    AL,1              ;zero or one?
           Je   Blit_C3             ;set it (one)
           Not   DL                 ;invert the mask to all but one bit set
           And   ES:[DI],DL         ;and clear that one 0 bit
           Not   DL                 ;put it back to normal
           Jmp   Short Blit_C4      ;do pointer and mask stuff now
Blit_C3:
           Or    ES:[DI],DL         ;set the pixel, don't touch others
Blit_C4:
           Shr   DL,1               ;shift the mask bit right
           Jnc   Blit_C5            ;no bits fell off, don't need new mask yet
           Mov   DL,80h             ;hi bit set
           Inc   DI                 ;and next screen byte
Blit_C5:
           Loop  Blit_C1            ;for 'truewidth' pixels
	   Jmp	 short Blit_C6x	    ; done
;
; Special loop if no transparent color
;
Blit_C1nt:
           LodSB                    ;AL = pixel value (0 or 1)
           And   AL,1               ;zero or one?
           Je    Blit_C2nt          ;set it (one)
           Not   DL                 ;invert the mask to all but one bit set
           And   ES:[DI],DL         ;and clear that one 0 bit
           Not   DL                 ;put it back to normal
           Jmp   Short Blit_C3nt    ;do pointer and mask stuff now
Blit_C2nt:
           Or    ES:[DI],DL         ;set the pixel, don't touch others
Blit_C3nt:
           Shr   DL,1               ;shift the mask bit right
           Jnc   Blit_C4nt          ;no bits fell off, don't need new mask yet
           Mov   DL,80h             ;hi bit set
           Inc   DI                 ;and next screen byte
Blit_C4nt:
           Loop  Blit_C1            ;for 'truewidth' pixels
;
; Okay, go back to normal
;
Blit_C6x:
           Push  SS                 ;in small model, SS == C's DS
           Pop   DS                 ;so recover it this way
           Mov   AX,PicWidth        ;width of a buffered line in bytes
           Add   Word Ptr TempBuff,AX ;skip the entire line width
;           @Normalize TempBuff      ;clean it up
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Pop   DX                 ;recover line count from TOS
           Dec   DX                 ;one less line to do
           Je    Blit_C6	    ;no more left
	   Jmp	 Blit_C0            ;back for more unless zero to do
Blit_C6:
           Ret                      ;done
Blit_CGA   EndP
;..........................................................................

           Even
;--------------------------------------------------------------------------
; GrafInit: Initialize Trivia variables for the indicated graphics mode.
;           In this version of the graphics driver, all input comes in as
;           single byte pixel values irregardless of graphics data type.
;           Therefore the calculations for widths and byte counts in the
;           various buffers can all be done here instead of by each
;           initializing function.
; On exit, DS is assumed to have been preserved.
;--------------------------------------------------------------------------
GrafInit   Proc  Near
;--------------------------------------------------------------------------
; Calc. number of lines Picbuff will hold of this picture.  Since the
; standard in use are unpacked bytes, one per pixel:
;          PicLines = (Pic_buff_size * 16) / PicWidth
;--------------------------------------------------------------------------
           Mov   AX,Pic_buff_size   ;size of Picbuff in paragraphs
           Mov   CL,4               ;2^4 = 16
           Shl   AX,CL              ;*16 convert to bytes
           Xor   DX,DX              ;MSW of 32 bit register
           Mov   CX,PicWidth        ;width (1 based)
           Div   CX                 ;AX = result; DX = remainder (ignored)
           Mov   PicLines,AX        ;save result
;--------------------------------------------------------------------------
; Calc. the number of bytes to unpack before performing the graphics blit:
;          PicLimit = PicLines * PicWidth
;--------------------------------------------------------------------------
           Xor   DX,DX              ;clear MSW again (CX is still PicWidth)
           Mul   CX                 ;AX = PicLines * PicWidth
           Mov   PicLimit,AX        ;since byte per pixel, stop here
;--------------------------------------------------------------------------
; Find the 'true width' of the display buffer, or the number of pixels
; (bytes) that will fit on one clipped line.
;--------------------------------------------------------------------------
;           Mov   AX,CoordX1         ;right edge
;           Sub   AX,CoordX0         ;find port width (NOT picture width)
           Mov   AX,PicWidth
           Mov   TrueWidth,AX       ;number of bytes (pixels) to show in port
;--------------------------------------------------------------------------
; Now setup for the Y table initializations
;--------------------------------------------------------------------------
           Push  DS                 ;also known as
           Pop   ES                 ;a mov es,ds
           Mov   DI,Offset Dgroup:YTable ;common entry condition
           Mov   CX,200             ;# of lines in each graphics mode
           Cmp   Display,USE_CGA    ;CGA 640 x 200 2 color?
           Je    Init_CGA           ;yes
GrafInit_0:
           Cmp   Display,USE_EGA    ;EGA 640 x 200 16 color?
           Je    Init_EGA           ;yes
GrafInit_1:
           Cmp   Display,USE_VGA    ;MCGA/VGA 320 x 200 256 color?
           Je    Init_VGA           ;3rd of 3 possible
           Ret                      ;sorry, nothing matched

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_CGA: Initialize Trivia variables for the CGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_CGA:
           Mov   BX,CoordX0         ;find starting bit mask
           And   BX,7               ;by taking X mod 8 as an index
           Mov   AL,BitTable[BX]    ;into the bit table
           Mov   StartMask,AL       ;put it here for Blit_CGA to use
           Cmp   GrafSeg,0          ;need to do more?
           Jne   Init_CGA_2         ;no
           Mov   GrafSeg,SEG_CGA    ;install the segment pointer
           Xor   BX,BX              ;this will count lines 0..199
Init_CGA_1:
           Mov   DX,BX              ;current line number
           Mov   DH,DL              ;multiply by 256 (8 shifts left)
           And   DX,1feh            ;force into range (l shifted with clr 0b)
           Shl   DX,1               ;*512
           Shl   DX,1               ;*1024
           Shl   DX,1               ;*2048
           Mov   AX,DX              ;working copy
           And   AH,7               ;gimmie lower 3 bits
           Shl   DX,1               ;still higher
           Shl   DX,1               ;last one (promise)
           Add   AX,DX              ;we've got interlace and offset now
           StoSW                    ;save the crazy result
           Inc   BX                 ;next line 0..199
           Loop  Init_CGA_1         ;that's 200 lines
Init_CGA_2:
           Ret

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_VGA: Initialize Trivia variables for the VGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_VGA:
           Cmp   GrafSeg,0          ;already done the init?
           Jne   Init_VGA_1         ;sure have
           Mov   GrafSeg,SEG_VGA    ;install the segment pointer
           Xor   AX,AX              ;initialize Y buffer offset to zero
Init_VGA_0:
           StoSW                    ;save the Y offset for this line
           Add   AX,320             ;320 bytes per line (byte per pixel) linear
           Loop  Init_VGA_0         ;for 200 lines (200 downto 1)
Init_VGA_1:
           Ret                      ;done with init

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_EGA: Initialize Trivia variables for the EGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_EGA:
           Push  CX                 ;save the 200 entry condition
           Mov   BX,CoordX0         ;find starting bit mask
           And   BX,7               ;by taking X mod 8 as an index
           Mov   AL,BitTable[BX]    ;into the bit table
           Mov   StartMask,AL       ;put it here for Blit_CGA to use
;--------------------------------------------------------------------------
; Find the value for TrueOffset and EGACount, where
;          EGACount   - number of bytes in line segment to move
;          TrueOffset - The 'real' starting byte offset (0..79) from the
;                       left edge of the Y line being processed.
;--------------------------------------------------------------------------
           Mov   CL,3               ;setup for div 8 operations
           Mov   AX,CoordX0         ;starting X
	   Mov	 DX,AX
	   Add	 DX,TrueWidth
	   Dec	 DX
;           Mov   DX,CoordX1         ;ending X
           Shr   AX,CL              ;convert to byte offset
           Shr   DX,CL              ;same here
           Sub   DX,AX              ;line width
           Inc   DX                 ;plus one for CX looping value
           Mov   EGACount,DX        ;here's the width, ra ra ra
           Mov   TrueOffset,AX      ;starting byte offset X0
Init_EGA_0:
           Pop   CX                 ;restore entry register
           Cmp   GrafSeg,0          ;need this other init too?
           Jne   Init_EGA_2         ;yup
           Mov   AX,SEG_EGA         ;video segment
           Mov   GrafSeg,AX         ;install the segment pointer
           Xor   AX,AX              ;initialize Y buffer offset to zero
Init_EGA_1:
           StoSW                    ;save the Y offset for this line
           Add   AX,640/8           ;80 bytes per line linear mapping
           Loop  Init_EGA_1         ;for 200 lines (200 downto 1)
Init_EGA_2:
           Ret                      ;all for now

GrafInit   EndP


;--------------------------------------------------------------------------

;=============================================================================

           @FUNC disp_pic_f,<X0:Word,Y0:Word,W:Word,H:Word,X1:Word,Y1:Word,HANDLE:Word,TRANS:Byte>
           @LINK SI,DI,DS
           Mov   PickUnpack,FileUnpack    ;tell LZ input is from a file
           Mov   AL,TRANS           ;transparent color
           Mov   TransColor,AL      ;pass to Trivia via data segment
           Mov   AX,HANDLE          ;open file's handle
           Mov   FileHandle,AX      ;make it 'global'
           @StandardEntry           ;load registers for standard entry to Trivia
           Call  Trivia             ;go for it
           @UNLINK                  ;sure, it looks easy
disp_pic_f EndP

;=============================================================================

           @FUNC disp_pic_b,<X0:Word,Y0:Word,W:Word,H:Word,X1:Word,Y1:Word,BUF_OFS:Word,BUF_SEG:Word,TRANS:Byte>
           @LINK SI,DI,DS
           Mov   PickUnpack,BufUnpack     ;tell LZ input is from a buffer
           Mov   AL,TRANS           ;transparent color
           Mov   TransColor,AL      ;pass to Trivia via data segment
           Mov   AX,BUF_OFS         ;32 bit parms don't work so well 
           Mov   Word Ptr InputBuff,AX
           Mov   AX,BUF_SEG         ;so it's back to word kludges for now
           Mov   Word Ptr InputBuff+2,AX
           @Normalize InputBuff     ;normalize the pointer for our consumption
           @StandardEntry           ;setup
	   Cld			    ; make sure direction flag is positive
           Call  Trivia             ;work work wrok
           @UNLINK                  ;see ya
disp_pic_b EndP

           End

;----------------------------------------------------------------------------

           Page  80,132
           Title Trivia - A Graphics Blit/Compression Software Package

;===========================================================================;
;                       'Trivia' project source code                        ;
;                                                                           ;
;  Compression and graphics routines for MCGA, VGA, EGA, and CGA graphics   ;
;                                                                           ;
;                              by John Fachini                              ;
;                      Inside Out Software Incorporated                     ;
;                      For exclusive use by Infocom, Inc.                   ;
;                                                                           ;
;                           Last modified:   May 12, 1989                   ;
;                           Version:         1.11                           ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                           Project specifications:                         ;
;                                                                           ;
; Graphics modes supported:         CGA   640 x 200   2 color               ;
;                                   EGA   640 x 200  16 color               ;
;                                   VGA   320 x 200 256 color               ;
;                                   MCGA  320 x 200 256 color               ;
;                                                                           ;
; Entry points:                                                             ;
;                                                                           ;
;      void cdecl disp_pic_f(x,y,width,height,rx,by,handle,transparent)     ;
;      unsigned int x,y;            /* upper left corner of blit region */  ;
;      unsigned int width,height;   /* width, height of graphics image */   ;
;      unsigned int rx,by;          /* lower right point of blit region */  ;
;      unsigned int handle;         /* file handle of open data file */     ;
;      unsigned char transparent;   /* Transparent color (0xff if none)     ;
;                                                                           ;
;      void cdecl disp_pic_b(x,y,width,height,rx,by,bptr,transparent)       ;
;      unsigned int x,y;            /* upper left corner of blit region */  ;
;      unsigned int width,height;   /* width, height of graphics image */   ;
;      unsigned int rx,by;          /* lower right point of blit region */  ;
;      unsigned char far *bptr;     /* 32 bit address of pre-loaded image */;
;      unsigned char transparent;   /* Transparent color (0xff if none)     ;
;                                                                           ;
; Global variables available at run-time:                                   ;
;                                                                           ;
;      void far *Hash_buff;         /* 12K LZ hash landing area */          :
;      void far *Pic_buff;          /* available buffer pre-allocated */    ;
;      unsigned int Pic_buff_size;  /* size in paragraphs of Pic_buff */    ;
;      unsigned char Display;       /* Display mode (1, 2, or 4) */         ;
;                                                                           ;
; The mission:                                                              ;
;                                                                           ;
;      Blit a compressed image from buffer or file into the indicated       ;
;      screen region, applying transparent color and clipping to the lower  ;
;      right bounds passed in.                                              ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;           Assembled by the Microsoft Macro Assembler version 5.1          :
;                           Options: /V /W2 /Z /Mx                          ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                              Revision History:                            ;
;                                                                           ;
; Version 1.00   -   Initial working code.                                  ;
; Version 1.01   -   Modified to perform blits by line rather than by plane ;
;                    when in EGA 640x200 mode.                              ;
; Version 1.02   -   Uses half of Pic_Buff for EGA buffering instead of     ;
;                    segment B000 to ensure compatibility with clone EGA    ;
;                    cards.                                                 ;
; Version 1.03   -   Blits one line at a time and leaves Pic_buff to full   ;
;                    size.                                                  ;
;                                                                           ;
; Version 1.10   -   Fixed for assembly under Turbo ASM:                    ;
;                       Changed "Extrn C" to just "Extrn"                   ;                        
;                       Changed "Proc C" to just "Proc" in FUNC macro       ;
;                       Add "Publc FuncName" to FUNC macro                  ;
;                       Add "Proc Near" to all functions                    ;
;                        and all matching EndP's                            ;
;                       Make GrafInit be one Proc                           ;
;									    ;
; Version 1.11  -   Made a YTable, GrafSeg, and EGAScratch Public for the   ;
;			scrolling routines				    ;
;									    ;
;***************************************************************************;
;                                                                           ;
;                 First released version to Infocom:    1.03                ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;            "Trivia" - an album by Utopia featuring Todd Rundgren          ;
;              Copyright (C) 1986 Utopia and Passport Records Inc.          ;
;                                                                           ;
;===========================================================================;

           .MODEL  Small,C          ;small memory model, C language

;--------------------------------------------------------------------------
;  C function interface macro
;--------------------------------------------------------------------------
@FUNC      Macro FuncName,FuncParameters
        Public FuncName
FuncName   Proc  FuncParameters                    ;declare public func
           IFNB  <FuncParameters>                    ;for any and all parms
           Irp   @FuncArg,<FuncParameters>           ;state parms to masm
           EndM
           EndIf
           EndM

;--------------------------------------------------------------------------
;  Stack interface macros
;--------------------------------------------------------------------------
@@CheckRegister Macro RegisterToCheck
           IfIdnI  <RegisterToCheck>,<SI>
@SI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DI>
@DI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DS>
@DS_Saved  =     1
           EndIf
           EndM


@LINK      Macro Reg1,Reg2,Reg3
@SI_Saved  =     0                                   ;clear each pushed
@DI_Saved  =     0                                   ;register variable
@DS_Saved  =     0                                   ;this invokation
           IFNB  <Reg1>                              ;check 1 of 3
           @@CheckRegister Reg1
           EndIf
           IFNB  <Reg2>                              ;check 2 of 3
           @@CheckRegister Reg2
           EndIf
           IFNB  <Reg3>                              ;check 3 of 3
           @@CheckRegister Reg3
           EndIf
           if    @SI_Saved                           ;if var says so,
           Push  SI                                  ;push the register
           EndIf
           If    @DI_Saved
           Push  DI
           EndIf
           If    @DS_Saved
           Push  DS
           EndIf
           EndM

@UNLINK    Macro
           If    @DS_Saved                           ;in reverse order as above
           Pop   DS
           EndIf
           If    @DI_Saved
           Pop   DI
           EndIf
           If    @SI_Saved
           Pop   SI
           EndIf
           Ret                                       ;C pops parms, not me
           EndM

;--------------------------------------------------------------------------
;  Graphics card and system variable equates  
;--------------------------------------------------------------------------
USE_CGA    equ   1                  ;'Display' value for CGA 640 x 200
USE_EGA    equ   2                  ;'Display' value for EGA 640 x 200
USE_VGA    equ   4                  ;'Display' value for VGA/MCGA 320 x 200

SEG_CGA    equ   0b800h             ;Segment of CGA video memory
SEG_EGA    equ   0a000h             ;Segment of EGA video memory
SEG_VGA    equ   0a000h             ;Segment of VGA video memory

EGA_SEGOFS equ   1000h              ;paragraphs to skip to second video page

BufUnpack  equ   0                  ;unpack from buffer mode
FileUnpack equ   1                  ;unpack from input file

;--------------------------------------------------------------------------
;  EGA Hardware equates and macros
;--------------------------------------------------------------------------
Plane_Select equ 3c4h               ;Plane select port
Mask_Select  equ 3ceh               ;Mask/Mode select port

;----------------------------------------------------------
; Used by most Out port routines (from the IBM tech-ref)
;----------------------------------------------------------
@OutDX     Macro
           Out   DX,AL
           Inc   DX
           Mov   AL,AH
           Out   DX,AL
           EndM

;--------------------------------------------------------------------------
; Select AH planes as write-able.  Bits 0 - 3 correspond to planes 0 - 3
;--------------------------------------------------------------------------
@WritePlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,2
           Mov   DX,Plane_Select
           @OutDX
           EndM

;-----------------------------------------------------------
; Enable a plane for reading: AH contains plane # (0 - 3)
;-----------------------------------------------------------
@ReadPlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,4
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------------------
; Enable writes to bits according to mask in AH (set bits are enabled)
;-------------------------------------------------------------------------
@WriteMask Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,8
           Mov   DX,Mask_Select
           @OutDX
           EndM

;----------------------------------------------------------
; Set a write mode given mode # in AH
;----------------------------------------------------------
@WriteMode Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,3
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------
; Set EGA graphics to normal write operations
;-------------------------------------------------------------
@NormalMode Macro
           @WriteMode 0
           EndM

;----------------------------------------------------------------------
; Reset the state of the EGA card: all planes, all bits enabled.
;----------------------------------------------------------------------
@ResetEGA  Macro
           @NormalMode
           @WritePlane 0fh
           @WriteMask 0ffh
           EndM

;--------------------------------------------------------------------------
; SetALPixel - set plane layout at ES:DI as bits in lo nibble of AL
;              All registers preserved.
;--------------------------------------------------------------------------
@SetALPixel Macro
           Local P1Check,P2Check,P3Check,SetExit
           Not   DL                 ;convert to one clear bit
           And   ES:[DI    ],DL     ;clear all 4 bit planes by default
           And   ES:[DI+ 80],DL     ;2 of 4
           And   ES:[DI+160],DL     ;3 of 4
           And   ES:[DI+240],DL     ;4 of 4
           Not   DL                 ;reset the bit mask
           Test  AL,1               ;plane 0 need setting?
           Je    P1Check            ;no, check plane 1
           Or    ES:[DI],DL         ;set it
P1Check:
           Test  AL,2               ;plane 1 need setting?
           Je    P2Check            ;no, check plane 2
           Or    ES:[DI+80],DL      ;set it
P2Check:
           Test  AL,4               ;plane 2 need setting?
           Je    P3Check            ;no, check plane 3
           Or    ES:[DI+160],DL     ;set it
P3Check:
           Test  AL,8               ;plane 3 need setting?
           Je    SetExit            ;done
           Or    ES:[DI+240],DL     ;set it
SetExit:
           EndM
           
;--------------------------------------------------------------------------
;  MS-DOS macros and equates for use with the LZ decompression
;--------------------------------------------------------------------------
@Mov32     Macro Dest32,Src32
           Mov   AX,Word Ptr Src32
           Mov   Word Ptr Dest32,AX
           Mov   AX,Word Ptr Src32+2
           Mov   Word Ptr Dest32+2,AX
           EndM

@Normalize Macro Ptr32
           Mov   AX,Word Ptr Ptr32  ;offset in 32 bit field
           Mov   CL,4               ;shift factor
           Shr   AX,CL              ;get rid of lo nibble, shift other 12 down
           And   AX,0fffh           ;for neatness sake
           Add   Word Ptr Ptr32+2,AX ;add in the remnants of the oversized ofs
           And   Word Ptr Ptr32,0fh ;and force the offset in range 00..0f
           EndM

@Dos_Int   Macro CmdCode
           Mov   AH,CmdCode
           Int   21h
           EndM

@FRead     Macro Handle,ReadLength
           IfNB  <Handle>
                 IfDifI <BX>,<Handle>
                 Mov   BX,Handle
                 EndIf
           EndIf
           IfNB <ReadLength>
                 IfDifI <CX>,<ReadLength>
                 Mov   CX,ReadLength
                 EndIf
           EndIf
           @Dos_Int 3fh
           EndM

;--------------------------------------------------------------------------
; LZ decompression constants
;--------------------------------------------------------------------------
Clr_Token  equ   256                ;clear hash table token
Eof_Token  equ   257                ;end of compressed stream token
FF_Token   equ   258                ;first free hash entry token

;--------------------------------------------------------------------------
;  LZ hash table structure 
;--------------------------------------------------------------------------
HashStruct Struc
Next       dw    ?
Char       db    ?
HashStruct EndS

;--------------------------------------------------------------------------
; LZ macros for much improved decompression performance.  These were
; subroutines once but the routine proved too slow on 4.77 MHz machines.
; Also note: the register assumptions during the execution of the LZ
; decompression loop are minimal:
;          DS : C's data segment
; That's it.
; Wake up J.D.!
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
; @Index: Return BX * 3 (3 = sizeof(HashStruc))
;--------------------------------------------------------------------------
@Index     Macro
           Push  AX                 ;preserve AX
           Mov   AX,BX              ;temp storage
           Shl   BX,1               ;BX * 2
           Add   BX,AX              ;add makes it *3
           Pop   AX                 ;restore AX
           EndM

;--------------------------------------------------------------------------
; @Add_Code: Add a code to the hash table.
;            On exit, AX, BX, ES, and DI are trashed
;--------------------------------------------------------------------------
@Add_Code  Macro
           Mov   BX,FreeCode        ;BX = next free code from local storage
           @Index                   ;build index into hash table
           Les   DI,Hashbuff        ;12K hash area address
           Add   DI,BX              ;add in the hash index
           Mov   AL,K               ;setup for the move
           Mov   ES:[DI].Char,AL    ;save the char in the hash rec
           Mov   AX,OldCode         ;linkage
           Mov   ES:[DI].Next,AX    ;as next ptr
           Inc   FreeCode           ;next one is free
           EndM

;--------------------------------------------------------------------------
; @Init_Table: setup local vars for table initialization
;--------------------------------------------------------------------------
@Init_Table Macro
           Mov   NBits,9            ;Starting with 9 bit codes
           Mov   MaxCode,512        ;10 0000 0000 b
           Mov   FreeCode,FF_Token  ;Reset next code free entry
           EndM

;--------------------------------------------------------------------------
; @Write_Char: Store the decompressed byte in AL into the dest buffer.
;              On exit, DI is trashed.  The modification made to this
;              routine counts the bytes written, watches for the
;              calculated byte limit to be hit and the graphics blit
;              is forced.  Normally the graphics code (noted below)
;              would not appear in the macro.
;--------------------------------------------------------------------------
@Write_Char Macro
           Local Write_Char_1,Write_Char_2
           Les   DI,Tempbuff        ;32 bit dest for the byte
           StoSB                    ;write the new byte into the buffer
           Inc   Word Ptr Tempbuff  ;next offset
           Cmp   DI,16              ;time to normalize the 32 bit pointer?
           Jne   Write_Char_1       ;no
           Inc   Word Ptr Tempbuff+2  ;increment the segment pointer
           Mov   Word Ptr Tempbuff,0  ;with offset 0
Write_Char_1:
           Inc   ByteCount          ;another byte's been written
           Mov   AX,ByteCount
           Cmp   AX,PicLimit        ;time to do the blit?
           Jne   Write_Char_2       ;nope
           Call  Blit               ;go for it
Write_Char_2:
           EndM

;--------------------------------------------------------------------------
; @Read_Code: process a code from the input stream
;--------------------------------------------------------------------------
@Read_Code Macro
           Local Read_Code_0,Read_Code_1,Read_Code_2,Read_Code_3,Read_Code_4,read_code_98,read_code_99
           Mov   AX,BitOffset       ;current bit offset
           Add   AX,NBits           ;add in current width
           Xchg  BitOffset,AX       ;swap em
           Mov   CX,8               ;Find byte/bit offset
           Xor   DX,DX              ;clear DX (MSW for div)
           Div   CX                 ;AX = result, DX remainder
           Cmp   AX,BUFSIZE-3       ;Nearing buffer full?
           Jl    Read_Code_0        ;no
           Push  DX                 ;save bits remaining calc
           Add   DX,NBits           ;Add bits to bits
           Mov   BitOffset,DX       ;new bit offset
           Mov   CX,BUFSIZE         ;buffer size
           Push  AX                 ;Save byte offset
           Sub   CX,AX              ;bytes left
           Push  DS
           Pop   ES                 ;ES,DS both C's DS
           Mov   SI,Offset Dgroup:Buffer
           Mov   DI,SI              ;base pointers for both
           Add   SI,AX              ;source skips ahead
           Rep   MovSB              ;'slide' the buffer
           Pop   CX                 ;pop byte offset (# of bytes to refill)
           Cmp   PickUnpack,FileUnpack ;use file?
           Je    Read_Code_3        ;yup
           Push  DS                 ;save C's DS
           Lds   SI,InputBuff       ;input buffer points to mem source
           Rep   MovSB              ;do 'read'
           Pop   DS                 ;restore me
           Mov   Word Ptr InputBuff,SI ;update to the new source offset
           @Normalize InputBuff     ;and normalize it
           Jmp   Short Read_Code_4  ;continue
Read_Code_3:
           Mov   DX,DI              ;pointer to read's dest
           @Fread FileHandle        ;gimmie more
Read_Code_4:
           Pop   DX                 ;get bit offset back from TOS
           Xor   AX,AX              ;read at start of buffer again (offset 0)
Read_Code_0:
           Mov   SI,Offset Dgroup:Buffer
           Add   SI,AX              ;offset into read buf
           LodSW                    ;get 'next' from record
           Mov   BX,AX              ;save it here
           LodSB                    ;get 'char'
           Mov   CX,DX              ;setup loop usage
           Jcxz  Read_Code_2        ;no need to do shifting
Read_Code_1:
           Shr   AL,1               ;drop lo bit into carry
           Rcr   BX,1               ;catch it here
           Loop  Read_Code_1        ;let CX say when to stop
Read_Code_2:
           Mov   AX,BX              ;what's left here we need too
           Mov   BX,NBits           ;bit count
           Sub   BX,9               ;generate index 0..3 inclusive
           Shl   BX,1               ;convert to word index
           And   AX,Masks[BX]       ;leave 9,10,11, or 12 bits
           EndM


;--------------------------------------------------------------------------
; Standardize entry macro for the "Trivia" routine
;--------------------------------------------------------------------------
@StandardEntry Macro
           Mov   AX,X0              ;upper left X in AX
           Mov   BX,Y0              ;upper left Y in BX
           Mov   CX,X1              ;lower right X in CX
           Mov   DX,Y1              ;lower right Y in CX
           Mov   SI,W               ;picture width in SI
           Mov   DI,H               ;picture height in DI
           EndM


;************************ The real stuff starts here *************************

           .Data
;--------------------------------------------------------------------------
;  External variable declarations
;--------------------------------------------------------------------------
           Extrn Hash_buff        : DWord          ;pointer to 12K hash area
           Extrn Pic_buff         : DWord          ;pointer to scratch area
           Extrn Pic_buff_size    : Word           ;size in para of Pic_buff
           Extrn Display          : Byte           ;display type field

	   Public YTable
	   Public GrafSeg
	   Public EGAScratch

BUFSIZE    equ   1024               ;Must be at least 1K and an even number
;--------------------------------------------------------------------------
;  "Trivia"'s kept variable space (sorry so much...)
;--------------------------------------------------------------------------
Buffer     db    BUFSIZE dup (?)    ;landing area for buffer input
EGAScratch db    80 * 4 dup (?)     ;bytes per line times 4 bit planes
Masks      dw    0000000111111111b  ;LZ bit masks (9 bits)
           dw    0000001111111111b  ;10 bits
           dw    0000011111111111b  ;11 bits
           dw    0000111111111111b  ;12 bits
BitOffset  dw    ?                  ;current bit offset
CurCode    dw    ?                  ;current code
OldCode    dw    ?                  ;last code processed
InCode     dw    ?                  ;code in use
FreeCode   dw    ?                  ;next free code for hash table entry
StackCount dw    ?                  ;count of pushed words
MaxCode    dw    ?                  ;max usable code this pass
NBits      dw    ?                  ;number of bits in current code
ByteCount  dw    ?                  ;number of bytes written since last blit
FinalChar  db    ?                  ;last unpacked
K          db    ?                  ;current unpacked

           Even
;--------------------------------------------------------------------------
; Graphics driver variable space
;--------------------------------------------------------------------------
GrafSeg    dw    0                  ;active graphics segment
Picbuff    dd    0                  ;32 bit scratch pointer to Pic_buff
Tempbuff   dd    0                  ;32 bit scratch pointer reset per blit
Hashbuff   dd    0                  ;32 bit scratch pointer to Hash_buff
BitTable   db    10000000b          ;mask for bit 0 set
           db    01000000b          ;mask for bit 1 set
           db    00100000b          ;and so on
           db    00010000b
           db    00001000b
           db    00000100b
           db    00000010b
           db    00000001b
YTable     dw    200 dup (?)        ;200 lines in each display mode
CoordX0    dw    ?                  ;upper left X coord this call
CoordY0    dw    ?                  ;upper left Y coord this call
CoordX1    dw    ?                  ;lower right X coord this call
CoordY1    dw    ?                  ;lower right Y coord this call
PicWidth   dw    ?                  ;image width in pixels (1 based)
PicHeight  dw    ?                  ;image height in pixels (1 based)
PicLines   dw    ?                  ;number of lines Picbuff will hold
PicLimit   dw    ?                  ;number of bytes to unpack before blit
CurrentY   dw    ?                  ;last referenced Y co-ord during blit
LineCount  dw    ?                  ;line counter during blit operation
TrueWidth  dw    ?                  ;byte width of line with clipping applied
FileHandle dw    ?                  ;file handle in use
InputBuff  dd    ?                  ;input buffer in leiu of file handle
EGACount   dw    ?                  ;number of bytes to blit per line (EGA)
TrueOffset dw    ?                  ;calculated starting byte offset in EGA
TransColor db    ?                  ;transparent color, this call
StartMask  db    ?                  ;bit mask (CGA) for starting bit
PickUnpack db    ?                  ;unpack method (buffer or disk)

;************************** And finally... the code *************************

           .Code

;--------------------------------------------------------------------------
; Trivia:  main entry point for C callable routines.
; Input:   AX         - upper left X of dest region
;          BX         - upper left Y of dest region
;          CX         - lower right X of dest region
;          DX         - lower right X of dest region
;          SI         - picture width (1 based)
;          DI         - picture height (1 based)
;          TransColor - set to transparent color passed in from C
;          PickUnpack - Set to 'BufUnpack' or 'FileUnpack' constant
;                       on BufUnpack :
;                              InputBuff: normalized pointer to data
;                       on FileUîpack :
;                              FileHandle: input file's handle
;--------------------------------------------------------------------------
Trivia     Proc  Near

           Mov   CoordX0,AX         ;set the public access versions of vars
           Mov   CoordY0,BX
           Mov   CoordX1,CX
           Mov   CoordY1,DX
           Mov   PicWidth,SI
           Mov   PicHeight,DI
           Mov   CurrentY,BX        ;init. to top of screen buffer
;--------------------------------------------------------------------------
; Set up the local versions of Pic_buff and Hash_buff
;--------------------------------------------------------------------------
Trivia_0:
           @Mov32 PicBuff,Pic_Buff
           @Mov32 HashBuff,Hash_Buff
           @Normalize PicBuff
           @Normalize Hashbuff
           Call  GrafInit           ;init the graphics variables now
;--------------------------------------------------------------------------
; Initialize the LZ decompression variables
;--------------------------------------------------------------------------
           @Init_Table
           Mov   StackCount,0       ;word count of pushed items
           Mov   BitOffset,0        ;no bits so far
           Mov   ByteCount,0        ;no bytes written yet either
           @Mov32  TempBuff,PicBuff ;working copy of the picbuff
;--------------------------------------------------------------------------
; Initialize the buffer space by reading from input (either buffer or disk)
;--------------------------------------------------------------------------
           Cmp   PickUnpack,FileUnpack ;use files?
           Je    Trivia_F0          ;yup
           Push  DS
           Pop   ES                 ;ES == C's DS
           Lds   SI,InputBuff       ;DS:SI start of input buffer
           Mov   DI,Offset Dgroup:Buffer ;landing area is ES:DI
           Mov   CX,BUFSIZE/2       ;buffer size in words
           Rep   MovSW              ;fill buffer
           Push  SS
           Pop   DS                 ;DS back to 'normal'
           Mov   Word Ptr InputBuff,SI ;update the offset value
           @Normalize InputBuff     ;and normalize it (being consistent...)
           Jmp   Short Trivia_LZ0   ;jump to the decompress loop
;--------------------------------------------------------------------------
; Load the now un-initialize input buffer via the file handle
;--------------------------------------------------------------------------
Trivia_F0:
           Mov   DX,Offset Dgroup:Buffer ;DS:DX is dest buffer for DOS
           @FRead FileHandle,BUFSIZE     ;load from disk
;--------------------------------------------------------------------------
; Unpack loop entry point 
;--------------------------------------------------------------------------
Trivia_LZ0:
           @Read_Code               ;get next code from input stream
           Cmp   AX,Eof_Token       ;all done?
           Jne   Not_EOF            ;nope
;--------------------------------------------------------------------------
; We're done, blit what's left and return to C
;--------------------------------------------------------------------------
           Call  Blit               ;finish up with what's left
           Ret                      ;life goes on

Not_EOF:
           Cmp   AX,Clr_Token       ;smasm the hash table?
           Je    Not_EOF_1          ;yes sir
           Jmp   Process_Code       ;no, AX is a real compressed code
Not_EOF_1:
           @Init_Table              ;clear hash table
           @Read_Code               ;reload if needed, get next code
           Mov   CurCode,AX         ;current code
           Mov   OldCode,AX         ;same as for now
           Mov   K,AL               ;lo byte
           Mov   FinalChar,AL       ;lo byte
           @Write_Char              ;send the code back
           Jmp   Trivia_LZ0         ;and back for more
Process_Code:
           Mov   CurCode,AX         ;save the latest passed in
           Mov   InCode,AX          ;here too
           Cmp   AX,FreeCode        ;is it in the hash table yet?
           Jl    Tabled_Code        ;sure is
           Mov   AX,OldCode         ;gimmie this back
           Mov   CurCode,AX         ;curcode = oldcode
           Mov   AL,FinalChar       ;reload this too
           Push  AX                 ;save it (here's the stack usage stuff)
           Inc   StackCount         ;one more push has been done
Tabled_Code:
           Cmp   CurCode,0ffh       ;is it a 'char'?
           Jle   Its_A_Char         ;pass out the cigars, it is
           Mov   BX,CurCode         ;need an index so
           @Index                   ;give it
           Les   DI,Hashbuff        ;pointer to base of table
           Add   DI,BX              ;add in base and offset to table
           Mov   AL,ES:[DI].Char    ;grab the suffix
           Push  AX                 ;more of this stuff
           Inc   StackCount         ;stack space dwindles...
           Mov   AX,ES:[DI].Next    ;prefix
           Mov   CurCode,AX         ;our new current code
           Jmp   Short Tabled_Code  ;one more time...
Its_A_Char:
           Mov   AX,CurCode         ;active code
           Mov   FinalChar,AL       ;last char
           Mov   K,AL               ;here too
           Push  AX                 ;stack it up
           Inc   StackCount         ;one last time
           Mov   CX,StackCount      ;ready for the loop
Its_A_Loop:
           Pop   AX                 ;get the next char from TOS
           @Write_Char              ;write it to the output buffer
           Loop  Its_A_Loop         ;until the stack is balanced again
Clear_It:
           Mov   StackCount,CX      ;zero the stackcount
           @Add_Code                ;put code in table
           Mov   AX,InCode          ;in code
           Mov   OldCode,AX         ;is now the oldcode
           Mov   BX,FreeCode        ;next free
           Cmp   BX,MaxCode         ;max yet?
           Jl    No_Max             ;nope
           Cmp   NBits,12           ;run out of bits?
           Je    No_Max             ;stick with 12 'til the clear comes thru
           Inc   NBits              ;next (10,11,12)
           Shl   MaxCode,1          ;give it a bit in both places
No_Max:
           Jmp   Trivia_LZ0         ;back for more

Trivia     Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit: Call appropriate graphics blit function, reset 'ByteCount' and
;       Tempbuff values, and return.
;       On exit, DS and CX are preserved.
;--------------------------------------------------------------------------
Blit       Proc  Near

           Cmp   ByteCount,0        ;need to do this?
           Je    Blit_3             ;no need
           Push  DS                 ;save the
           Push  CX                 ;promised registers
           Mov   AX,ByteCount       ;this check is needed in case of
           Cmp   AX,PicLimit        ;a partially full buffer at the end of
           Je    Blit_00            ;the compression loop
           Xor   DX,DX              ;MSW
           Mov   CX,PicWidth        ;bytes in width
           Div   CX                 ;AX = new line count
           Mov   PicLines,AX        ;new line count this buffer
Blit_00:
           @Mov32  Tempbuff,Picbuff ;reset temp pointer to buffer start
           Mov   ES,GrafSeg         ;load this up by default
           Cmp   Display,USE_VGA    ;VGA/MCGA mode?
           Jne   Blit_0             ;no
           Call  Blit_VGA           ;yes
           Jmp   Short Blit_2       ;skip other tests
Blit_0:
           Cmp   Display,USE_EGA    ;EGA mode?
           Jne   Blit_1             ;sorry
           Call  Blit_EGA           ;go for it
           Jmp   Short Blit_2       ;skip to end
Blit_1:
           Cmp   Display,USE_CGA    ;CGA mode?
           Jne   Blit_2             ;forget it, just do cleanup
           Call  Blit_CGA           ;3rd of 3
Blit_2:
           Pop   CX                 ;back from TOS
           Pop   DS                 ;and NOS
           Mov   ByteCount,0        ;we've used up our bytes
Blit_3:
           @Mov32  Tempbuff,Picbuff ;reset the buffer pointer
           Ret                      ;and go unpack more data
Blit       Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_VGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_VGA   Proc  Near

           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_V0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Ja    Blit_V5            ;yes, time to go
           Mov   DI,BX              ;need the lookup
           Shl   DI,1               ;Ytable is a word table
           Mov   DI,YTable[DI]      ;got it
           Add   DI,CoordX0         ;add in the base X
           Mov   CX,TrueWidth       ;the 'real' line width displayable
           Mov   AH,TransColor      ;transparent color (0..fe)
           Lds   SI,Tempbuff        ;source
           Cmp   AH,0ffh            ;no mask?
           Je    Blit_V3            ;none: use the quick method
Blit_V1:
           LodSB                    ;AL = pixel value
           Cmp   AL,AH              ;write over screen byte?
           Je    Blit_V2            ;no, AL is "transparent"...
           Mov   ES:[DI],AL         ;put the new pixel in
Blit_V2:
           Inc   DI                 ;next byte in video buffer
           Loop  Blit_V1            ;for 'truewidth' pixels
           Jmp   Short Blit_V4      ;skip the easy move code
Blit_V3:
           Rep   MovSB              ;move those pixels
Blit_V4:
           Push  SS                 ;in small model, SS == C's DS
           Pop   DS                 ;so recover it this way
           Mov   AX,PicWidth        ;width of a buffered line in bytes
           Add   Word Ptr Tempbuff,AX ;skip the entire line width
           @Normalize TempBuff      ;clean it up
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Dec   DX                 ;one less line to do
           Jne   Blit_V0            ;back for more unless zero to do
Blit_V5:
           Ret                      ;done
Blit_VGA   Endp

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_EGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_EGA   Proc  Near
           Cmp   ByteCount,0        ;anything to 'blit'...?
           Je    Blit_E8            ;no, get outta here
           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_E0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Ja    Blit_E8            ;yes, get out quick
           Push  DX                 ;save this (only useful later)
           Push  ES                 ;make DS the video seg
           Pop   DS                 ;and make ES the data seg
           Push  SS                 ;small model
           Pop   ES                 ;there
           Call  CopyEGALine        ;copy line BX from video to buffer
           Call  ApplyEGAData       ;apply the unpacked data to video info
           Call  BlitEGALine        ;and show the new line on the screen
           Pop   DX                 ;back again
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Dec   DX                 ;one less line to do
           Jne   Blit_E0            ;back for more
Blit_E8:
           @ResetEGA                ;leave the card in normal state
           Ret                      ;done
Blit_EGA   Endp

;--------------------------------------------------------------------------
; CopyEGALine: read line BX from the video card and copy it into
;              EGAScratch so that the plane data aligns with the
;              +0,+80,+160,+240 offsets into the buffer.
; On entry, DS video segment, ES is C's DS, BX is line number.
; On exit,  DS, ES, and BX must be preserved.
;--------------------------------------------------------------------------
           Even
CopyEGALine  Proc Near

           Push  BX                 ;save me
           Shl   BX,1               ;*2
           Mov   SI,SS:YTable[BX]   ;starting position
           Mov   DI,Offset Dgroup:EGAScratch ;base internal line buffer
           Mov   BX,SS:EGACount     ;line width for looping
           Mov   DX,SS:TrueOffset   ;starting offsets from lines
           Add   SI,DX              ;add in the offset
           Add   DI,DX              ;for both buffers
           Xor   AH,AH              ;start with plane zero
CopyEGALine_0:
           @ReadPlane               ;read plane AH (0..3)
           Mov   AL,[SI]            ;latch in new state
           Mov   CX,BX              ;number of bytes to move
           Rep   MovSB              ;put it in the buffer
           Add   DI,80              ;skip to next plane
           Sub   DI,BX              ;backup for additional moves
           Sub   SI,BX              ;yea yea, here too
           Inc   AH                 ;next plane
           Cmp   AH,4               ;done yet?
           Jne   CopyEGALine_0      ;yes
           @ResetEGA                ;no, put the card in a nice state
           Pop   BX                 ;in the right order
           Ret                      ;see ya
CopyEGALine Endp

;--------------------------------------------------------------------------
; ApplyEGAData: Take from the TempBuff and apply unpacked bytes to the
;               bit plane formatted data in EGAScratch.
; On entry, DS = video seg, ES = C's DS, BX = current line
; On exit,  DS, ES, BX must be preserved
;--------------------------------------------------------------------------
           Even
ApplyEGAData  Proc Near
           Push  DS                 ;save me
           Mov   CX,SS:TrueWidth    ;the 'real' line width displayable
           Mov   AH,SS:TransColor   ;transparent color (0..fe)
           Mov   DI,Offset Dgroup:EGAScratch ;dest
           Add   DI,SS:TrueOffset   ;adjusted for byte position
           Mov   DL,SS:StartMask    ;starting bit mask value
           Lds   SI,SS:Tempbuff     ;source
	   cmp	 AH,0ffh	    ; are we doing anything transparent?
	   Je	 ApplyEGA_0nt	    ; nope, don't check
ApplyEGA_0:
           LodSB                    ;input byte (only lo nibble counts)
           Cmp   AL,AH              ;did we match?
           Je    ApplyEGA_2         ;yes, skip this here pixel
ApplyEGA_1:
           @SetALPixel              ;keep things simple this way
ApplyEGA_2:
           Shr   DL,1               ;slide mask down the bits
           Jnc   ApplyEGA_3         ;no drop off yet
           Mov   DL,80h             ;up to top of next byte
           Inc   DI                 ;and skip to next byte in buffer
ApplyEGA_3:
           Loop  ApplyEGA_0         ;for CX pixels in the buffer
	   Jmp	 short ApplyEGA_4    ; done
ApplyEGA_0nt:
           LodSB                    ;input byte (only lo nibble counts)
           @SetALPixel              ;keep things simple this way
           Shr   DL,1               ;slide mask down the bits
           Jnc   ApplyEGA_1nt       ;no drop off yet
           Mov   DL,80h             ;up to top of next byte
           Inc   DI                 ;and skip to next byte in buffer
ApplyEGA_1nt:
           Loop  ApplyEGA_0nt       ;for CX pixels in the buffer
ApplyEGA_4:
           Push  SS                 ;in small model, SS == C's DS
           Pop   DS                 ;so recover it this way
           Mov   AX,PicWidth        ;width of a buffered line in bytes
           Add   Word Ptr Tempbuff,AX ;skip the entire line width
           @Normalize TempBuff      ;clean it up
           Pop   DS                 ;restore video seg as DS (ES never changed)
           Ret                      ;and go back
ApplyEGAData   Endp


;--------------------------------------------------------------------------
; BlitEGALine: Move planed data from EGAScratch onto screen at Y line BX.
; On entry, DS = video segment, ES = C's data segment, BX = dest Y
; On exit,  DS = C's data segment, ES = video segment, BX preserved
;--------------------------------------------------------------------------
           Even
BlitEGALine  Proc Near

           Push  BX                 ;save for return to caller
           Push  DS                 ;need to swap these here segment registers
           Push  ES                 ;this should be familiar
           Pop   DS                 ;by now
           Pop   ES                 ;xchg ds,es
           Mov   DI,BX              ;dest Y
           Shl   DI,1               ;for lookup in table
           Mov   DI,YTable[DI]      ;base Y
           Mov   SI,Offset Dgroup:EGAScratch ;start of data (p0,p1,p2,p3)
           Mov   BX,TrueOffset      ;keep this around
           Add   DI,BX              ;offset to starting X byte
           Add   SI,BX              ;compensate here too
           Mov   BX,EGACount        ;number of bytes to move
           Mov   AH,1               ;write plane selector
EGALine_0:
           @WritePlane              ;enable the card
           Mov   AL,ES:[DI]         ;latch the new state in
           Mov   CX,BX              ;# of bytes to move
           Rep   MovSB              ;move data onto screen
           Shl   AH,1               ;next plane
           Add   SI,80              ;add in bytes per line; skip to next plane
           Sub   SI,BX              ;compensate for moved data
           Sub   DI,BX              ;one more
           Cmp   AH,10h             ;video seg hit end yet?
           Jne   EGALine_0          ;not yet
           Pop   BX                 ;get BX back from TOS
           Ret                      ;and go back
BlitEGALine EndP

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Blit_CGA: Fill the screen region defined by (X0,Y0) (X1,Y1) with the
;           image at Picbuff through Picbuff + ByteCount.
;           Apply clipping to the right and bottom parts of the picture.
; On entry, ES points to the video segment for this mode.
;--------------------------------------------------------------------------
Blit_CGA   Proc  Near
           Mov   DX,PicLines        ;reset the line counter for this call
           Mov   BX,CurrentY        ;start at current Y
Blit_C0:
           Cmp   BX,CoordY1         ;'down' out of range?
           Jna   Blit_C0x	    ;nope, doing just fine
           Jmp	 Blit_C6	    ;yes, time to go
Blit_C0x:
           Push  DX                 ;save line counter at TOS
           Mov   DI,BX              ;need the lookup
           Shl   DI,1               ;Ytable is a word table
           Mov   DI,YTable[DI]      ;got it
           Mov   AX,CoordX0         ;starting X
           Mov   CL,3               ;divide by 8
           Shr   AX,CL              ;to find starting byte (bit per pixel)
           Add   DI,AX              ;mix it in
           Mov   CX,TrueWidth       ;the 'real' line width displayable
           Mov   AH,TransColor      ;transparent 'bit'
           Mov   DL,StartMask       ;starting mask (single bit)
           Lds   SI,Tempbuff        ;source
           Cmp   AH,0ffh            ;transparent off?
           Je    Blit_C1nt	    ; not transparent color, so don't look
Blit_C1:
           LodSB                    ;AL = pixel value (0 or 1)
           Cmp   AL,AH              ;write over screen byte?
           Je    Blit_C4            ;no, AL is "transparent"...
Blit_C2:
           And    AL,1              ;zero or one?
           Je   Blit_C3             ;set it (one)
           Not   DL                 ;invert the mask to all but one bit set
           And   ES:[DI],DL         ;and clear that one 0 bit
           Not   DL                 ;put it back to normal
           Jmp   Short Blit_C4      ;do pointer and mask stuff now
Blit_C3:
           Or    ES:[DI],DL         ;set the pixel, don't touch others
Blit_C4:
           Shr   DL,1               ;shift the mask bit right
           Jnc   Blit_C5            ;no bits fell off, don't need new mask yet
           Mov   DL,80h             ;hi bit set
           Inc   DI                 ;and next screen byte
Blit_C5:
           Loop  Blit_C1            ;for 'truewidth' pixels
	   Jmp	 short Blit_C6x	    ; done
;
; Special loop if no transparent color
;
Blit_C1nt:
           LodSB                    ;AL = pixel value (0 or 1)
           And   AL,1               ;zero or one?
           Je    Blit_C2nt          ;set it (one)
           Not   DL                 ;invert the mask to all but one bit set
           And   ES:[DI],DL         ;and clear that one 0 bit
           Not   DL                 ;put it back to normal
           Jmp   Short Blit_C3nt    ;do pointer and mask stuff now
Blit_C2nt:
           Or    ES:[DI],DL         ;set the pixel, don't touch others
Blit_C3nt:
           Shr   DL,1               ;shift the mask bit right
           Jnc   Blit_C4nt          ;no bits fell off, don't need new mask yet
           Mov   DL,80h             ;hi bit set
           Inc   DI                 ;and next screen byte
Blit_C4nt:
           Loop  Blit_C1            ;for 'truewidth' pixels
;
; Okay, go back to normal
;
Blit_C6x:
           Push  SS                 ;in small model, SS == C's DS
           Pop   DS                 ;so recover it this way
           Mov   AX,PicWidth        ;width of a buffered line in bytes
           Add   Word Ptr TempBuff,AX ;skip the entire line width
           @Normalize TempBuff      ;clean it up
           Inc   BX                 ;next line
           Inc   CurrentY           ;here too
           Pop   DX                 ;recover line count from TOS
           Dec   DX                 ;one less line to do
           Je    Blit_C6	    ;no more left
	   Jmp	 Blit_C0            ;back for more unless zero to do
Blit_C6:
           Ret                      ;done
Blit_CGA   EndP
;..........................................................................

           Even
;--------------------------------------------------------------------------
; GrafInit: Initialize Trivia variables for the indicated graphics mode.
;           In this version of the graphics driver, all input comes in as
;           single byte pixel values irregardless of graphics data type.
;           Therefore the calculations for widths and byte counts in the
;           various buffers can all be done here instead of by each
;           initializing function.
; On exit, DS is assumed to have been preserved.
;--------------------------------------------------------------------------
GrafInit   Proc  Near
;--------------------------------------------------------------------------
; Calc. number of lines Picbuff will hold of this picture.  Since the
; standard in use are unpacked bytes, one per pixel:
;          PicLines = (Pic_buff_size * 16) / PicWidth
;--------------------------------------------------------------------------
           Mov   AX,Pic_buff_size   ;size of Picbuff in paragraphs
           Mov   CL,4               ;2^4 = 16
           Shl   AX,CL              ;*16 convert to bytes
           Xor   DX,DX              ;MSW of 32 bit register
           Mov   CX,PicWidth        ;width (1 based)
           Div   CX                 ;AX = result; DX = remainder (ignored)
           Mov   PicLines,AX        ;save result
;--------------------------------------------------------------------------
; Calc. the number of bytes to unpack before performing the graphics blit:
;          PicLimit = PicLines * PicWidth
;--------------------------------------------------------------------------
           Xor   DX,DX              ;clear MSW again (CX is still PicWidth)
           Mul   CX                 ;AX = PicLines * PicWidth
           Mov   PicLimit,AX        ;since byte per pixel, stop here
;--------------------------------------------------------------------------
; Find the 'true width' of the display buffer, or the number of pixels
; (bytes) that will fit on one clipped line.
;--------------------------------------------------------------------------
;           Mov   AX,CoordX1         ;right edge
;           Sub   AX,CoordX0         ;find port width (NOT picture width)
           Mov   AX,PicWidth
           Mov   TrueWidth,AX       ;number of bytes (pixels) to show in port
;--------------------------------------------------------------------------
; Now setup for the Y table initializations
;--------------------------------------------------------------------------
           Push  DS                 ;also known as
           Pop   ES                 ;a mov es,ds
           Mov   DI,Offset Dgroup:YTable ;common entry condition
           Mov   CX,200             ;# of lines in each graphics mode
           Cmp   Display,USE_CGA    ;CGA 640 x 200 2 color?
           Je    Init_CGA           ;yes
GrafInit_0:
           Cmp   Display,USE_EGA    ;EGA 640 x 200 16 color?
           Je    Init_EGA           ;yes
GrafInit_1:
           Cmp   Display,USE_VGA    ;MCGA/VGA 320 x 200 256 color?
           Je    Init_VGA           ;3rd of 3 possible
           Ret                      ;sorry, nothing matched

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_CGA: Initialize Trivia variables for the CGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_CGA:
           Mov   BX,CoordX0         ;find starting bit mask
           And   BX,7               ;by taking X mod 8 as an index
           Mov   AL,BitTable[BX]    ;into the bit table
           Mov   StartMask,AL       ;put it here for Blit_CGA to use
           Cmp   GrafSeg,0          ;need to do more?
           Jne   Init_CGA_2         ;no
           Mov   GrafSeg,SEG_CGA    ;install the segment pointer
           Xor   BX,BX              ;this will count lines 0..199
Init_CGA_1:
           Mov   DX,BX              ;current line number
           Mov   DH,DL              ;multiply by 256 (8 shifts left)
           And   DX,1feh            ;force into range (l shifted with clr 0b)
           Shl   DX,1               ;*512
           Shl   DX,1               ;*1024
           Shl   DX,1               ;*2048
           Mov   AX,DX              ;working copy
           And   AH,7               ;gimmie lower 3 bits
           Shl   DX,1               ;still higher
           Shl   DX,1               ;last one (promise)
           Add   AX,DX              ;we've got interlace and offset now
           StoSW                    ;save the crazy result
           Inc   BX                 ;next line 0..199
           Loop  Init_CGA_1         ;that's 200 lines
Init_CGA_2:
           Ret

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_VGA: Initialize Trivia variables for the VGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_VGA:
           Cmp   GrafSeg,0          ;already done the init?
           Jne   Init_VGA_1         ;sure have
           Mov   GrafSeg,SEG_VGA    ;install the segment pointer
           Xor   AX,AX              ;initialize Y buffer offset to zero
Init_VGA_0:
           StoSW                    ;save the Y offset for this line
           Add   AX,320             ;320 bytes per line (byte per pixel) linear
           Loop  Init_VGA_0         ;for 200 lines (200 downto 1)
Init_VGA_1:
           Ret                      ;done with init

;..........................................................................

           Even
;--------------------------------------------------------------------------
; Init_EGA: Initialize Trivia variables for the EGA routines
;           On entry, ES:DI points to YTable, CX = 200
;           On exit,  all non-segment registers trashed
;--------------------------------------------------------------------------
Init_EGA:
           Push  CX                 ;save the 200 entry condition
           Mov   BX,CoordX0         ;find starting bit mask
           And   BX,7               ;by taking X mod 8 as an index
           Mov   AL,BitTable[BX]    ;into the bit table
           Mov   StartMask,AL       ;put it here for Blit_CGA to use
;--------------------------------------------------------------------------
; Find the value for TrueOffset and EGACount, where
;          EGACount   - number of bytes in line segment to move
;          TrueOffset - The 'real' starting byte offset (0..79) from the
;                       left edge of the Y line being processed.
;--------------------------------------------------------------------------
           Mov   CL,3               ;setup for div 8 operations
           Mov   AX,CoordX0         ;starting X
           Mov   DX,CoordX1         ;ending X
           Shr   AX,CL              ;convert to byte offset
           Shr   DX,CL              ;same here
           Sub   DX,AX              ;line width
           Inc   DX                 ;plus one for CX looping value
           Mov   EGACount,DX        ;here's the width, ra ra ra
           Mov   TrueOffset,AX      ;starting byte offset X0
Init_EGA_0:
           Pop   CX                 ;restore entry register
           Cmp   GrafSeg,0          ;need this other init too?
           Jne   Init_EGA_2         ;yup
           Mov   AX,SEG_EGA         ;video segment
           Mov   GrafSeg,AX         ;install the segment pointer
           Xor   AX,AX              ;initialize Y buffer offset to zero
Init_EGA_1:
           StoSW                    ;save the Y offset for this line
           Add   AX,640/8           ;80 bytes per line linear mapping
           Loop  Init_EGA_1         ;for 200 lines (200 downto 1)
Init_EGA_2:
           Ret                      ;all for now

GrafInit   EndP


;--------------------------------------------------------------------------

;=============================================================================

           @FUNC disp_pic_f,<X0:Word,Y0:Word,W:Word,H:Word,X1:Word,Y1:Word,HANDLE:Word,TRANS:Byte>
           @LINK SI,DI,DS
           Mov   PickUnpack,FileUnpack    ;tell LZ input is from a file
           Mov   AL,TRANS           ;transparent color
           Mov   TransColor,AL      ;pass to Trivia via data segment
           Mov   AX,HANDLE          ;open file's handle
           Mov   FileHandle,AX      ;make it 'global'
           @StandardEntry           ;load registers for standard entry to Trivia
           Call  Trivia             ;go for it
           @UNLINK                  ;sure, it looks easy
disp_pic_f EndP

;=============================================================================

           @FUNC disp_pic_b,<X0:Word,Y0:Word,W:Word,H:Word,X1:Word,Y1:Word,BUF_OFS:Word,BUF_SEG:Word,TRANS:Byte>
           @LINK SI,DI,DS
           Mov   PickUnpack,BufUnpack     ;tell LZ input is from a buffer
           Mov   AL,TRANS           ;transparent color
           Mov   TransColor,AL      ;pass to Trivia via data segment
           Mov   AX,BUF_OFS         ;32 bit parms don't work so well 
           Mov   Word Ptr InputBuff,AX
           Mov   AX,BUF_SEG         ;so it's back to word kludges for now
           Mov   Word Ptr InputBuff+2,AX
           @Normalize InputBuff     ;normalize the pointer for our consumption
           @StandardEntry           ;setup
           Call  Trivia             ;work work wrok
           @UNLINK                  ;see ya
disp_pic_b EndP

           End

;----------------------------------------------------------------------------

;
; Jonathan Arnold's asm tries
;
        DOSSEG                  ; select Intel-contvention segment ordering
        .MODEL Small            ; Small C stuff

        .DATA                   ; TC-compatible init data segment
        EXTRN _Scrx, _Scry      ; Cursor X,Y pos
        EXTRN _Fgcolor, _Bgcolor ; Foreground/Background color of char
        EXTRN _Font             ; pointer to font data
	EXTRN _Win_hlmode	; Current highlight mode, for underlining
	EXTRN _Font_height	; Font height (no kidding)

        .DATA?                  ; TC-compatible un-init data segment
NextLine  DW    ?               ; offset to next line

        .CODE                   ; TC-compatible code segment
BitsPerLine    EQU     320      ; how many pixels in one line
UNDFLG	EQU	4		; bit in hlmode of underlining

;
; display_char13( character, cw, monoflag )
;       int character - character to output
;       int cw - character width
;	int monoflag - 0 if not monospaced, width of mono font if it is
;
;  Just print a character at position Scrx, Scry
;
; Courtesy of "Programmer's Guide to PC & PS/2 Video Systems", Richard Wilton
;       MicroSoft Press, pp. 286-288
;
        PUBLIC	_display_char13
_display_char13 PROC NEAR
        ARG   Character:WORD,Cw:WORD,MonoFlag:WORD
	LOCAL	Hlmode:WORD=AUTO_SIZE

        push    bp              ; preserve a few registers
        mov     bp,sp
        sub     sp,AUTO_SIZE    ; reserve some room for local vars
        push    di
        push    si
        push    ds

	mov	ax,_Win_hlmode	; save for later check
	mov	[Hlmode],ax
	cld			; make sure direction is postiive
;
; calculate first pixel address
;
        mov     ax,_Scry        ; get x,y pos
        mov     bx,_Scrx
        call    PixelAddr13     ; ES:BX point to start of buffer
        mov     di,bx           ; make it be ES:DI
;
; set up character definition table addressing
;
        mov     cx,8            ; CX = POINTS (pixel rows in chars)

        mov     ax,Word Ptr _Font+2 ; Get segment and offset
        push    ax              ; save a minute
        mov     ax,Word Ptr _Font   ; this is the offset
        mov     si,ax           ; put offset into si
        pop     ds              ; DS:SI - start of char table

        xor     ax,ax           ; magical clear
        mov     ax,[Character]  ; Character we would like to print
        mul     cl              ; AX - offset into char def table
        add     si,ax           ; SI - addr of char def
;
; figger offset to next line
;
        mov     ax,BitsPerLine  ; how many bits in one line
	cmp	[MonoFlag],0	; are we doing monospaced font?
	je	L01		; no
	sub	ax,[MonoFlag]	; then subtract mono spaced width
	jmp	short L02	; and done
L01:
        sub     ax,[Cw]         ; - width of char
L02:
        mov     NextLine,ax     ; = offset to next pixel line
;
; store the character in the video buffer
;
        mov     bl,_Fgcolor     ; BL - foreground pixel value
        mov     bh,_Bgcolor     ; BH - background pixel value

L10:    push    cx              ; preserve CX across loop
;
; check for underlining next to last line
;
	cmp	cx,1		; last line?
	jne	short LuM	; nope
	test	[Hlmode],UNDFLG ; underlining on?
	jz	short LuM	 ; nope
	mov	al,0FFh		; turn on all bits for underline
        mov     cx,[Cw]         ; CX - char width in pixels
	cmp	[MonoFlag],0	; monofont?
	je	short Ljd	; nope, so use this font
	mov	cx,[MonoFlag]	; use monofont width
	jmp	short Ljd	; done
LuM:
        lodsb   		; go get the char data
        mov     cx,[Cw]         ; CX - char width in pixels
;
; now, mess around with data if mono_spaced font
;
	cmp	[MonoFlag],0	; is it zero?
	je	Ljd		; yes, so no playing with it
	cmp	[MonoFlag],cx	; how does width look to it
	je	Ljd		; no messing if same width
	mov	ah,cl		; pick up real width
	mov	cx,[MonoFlag]	; set width to be mono width
	ja	Ljd1		; mono width is wider than normal width
;
; width is wider than mono width, so cut out 1/2 of extra
;
	sub	ah,cl		; see how much is left
	shr	ah,1		; 1/2 for extra at beginning
	mov	cl,ah		; get shifting amount
	shl	al,cl		; and move data to the left
	jmp	short Ljd2	; done
;
; Width is less than mono width, so try and center data
;
Ljd1:
	sub	cl,ah		; get how much wider is mono font
	shr	cl,1		; /2 to get amount at beginning
	jnc	Ljd10		; okay, no wrap
	inc	cl		; always move at least one
Ljd10:
	shr	al,cl		; and try to center data
Ljd2:
	mov	cx,[MonoFlag]	; set width to be mono width
Ljd:
        mov     ah,al           ; AH - bit pattern for next pixel row

L11:    mov     al,bh           ; let's assume background color more likely
        shl     ah,1            ; check pixel
        jnc     L12             ; okay, it is a background color
        mov     al,bl           ; oops, really foreground

L12:    stosb                   ; send out the pixel
        loop    L11             ; and check next one

        add     di,NextLine     ; point to next row of pixels
        pop     cx              ; get counter back
        loop    L10             ; go do next line

        pop     ds              ; get regs back
        pop     si
        pop     di
        mov     sp,bp
        pop     bp
        ret

_display_char13 ENDP

;
; PixelAddr13
;       Determine buffer addres of pixel in MCGA mode 13
;
; Inputs:
;       AX = y coordinate (0-199)
;       BX = x coordinate (0-319)
;
; Returns:
;       BX = byte offset in buffer
;       ES = video buffer segment
;
OriginOffset EQU 0
VideoBufferSeg EQU 0A000h

PixelAddr13 PROC NEAR
        xchg    ah,al           ; AX = 256*y
        add     bx,ax           ; BX = 256*y + x
        shr     ax,1
        shr     ax,1            ; AX = 64*y
        add     bx,ax           ; BX = 320*y + x
        add     bx,OriginOffset ; BX = byte offset into buffer
        mov     ax,VideoBufferSeg
        mov     es,ax           ; ES:BX = byte address of pixel
        ret
PixelAddr13 ENDP

;
; DisplayChar10( character ) - display a character in EGA Mode 0x0E
;       int character - character to output
;  Just print a character at position Scrx, Scry
;
; Courtesy of "Programmer's Guide to PC & PS/2 Video Systems", Richard Wilton
;       MicroSoft Press, pp. 28288-292
;
BytesPerLine    =       80

        PUBLIC _display_char10
_display_char10  PROC NEAR
        ARG     Character:WORD
        LOCAL   VARshift:WORD,Fore:BYTE,Back:BYTE,Hlmode:WORD=AUTO_SIZE

        push    bp              ; preserve a few registers
        mov     bp,sp
        sub     sp,AUTO_SIZE    ; reserve some room for local vars
        push    di
        push    si
        push    ds

	mov	ax,_Win_hlmode	; save for later check
	mov	[Hlmode],ax
	cld			; make sure direction is postiive

        mov     al,_Bgcolor     ; set back/foreground color
        mov     Back,al
        mov     al,_Fgcolor     ; we did
        mov     Fore,al
;
; calculate first pixel address
;
        mov     ax,_Scry        ; get x,y pos
        mov     bx,_Scrx
        call    PixelAddr10     ; ES:BX point to start of buffer
        mov     di,bx           ; make it be ES:DI

        inc     cx
        and     cl,7            ; CL == # bits to shift to mask char

        mov     ch,0FFh
        shl     ch,cl           ; CH == bit mask for right side of char
        mov     [VARshift],cx

        push    es              ; prevserve video buffer segment
        mov     si,bx           ; SI == video buffer offset
;
; set up char def table addressing
;
        mov     ax,40h
        mov     ds,ax           ; DS = segment of BIOS Video Display area
        mov     cx,ds:[85h]     ; CX = POINTS (rows in characters)

        xor     ax,ax           ; magical clear
        mov     ds,ax           ; DS = absolute zero

        mov     ax,[Character]  ; AL = character code
        mov     bx,43h*4        ; DS:BX - int 43 vector
        les     di,ds:[bx]      ; ES:DI - start of char table
        mul     cl              ; AX = offset into char table
        add     di,ax           ; DI = addr of char data
        pop     ds              ; DS:SI - video buffer
;
; set up Graphics Controller regs
;
        mov     dx,3CEh         ; Graphics Controller address reg port
        mov     ax,0A05h        ; AL = Mode register number
                                ; AH = Write mode 2 (bits 0-1)
                                ;       Read mode 1 (bit 4)
        out     dx,ax
        mov     ah,0            ; Read-Modify-Write bits (just move)
        mov     al,3            ; Data Rotate/Function Select reg
        out     dx,ax

        mov     ax,0007         ; AH = Color Don't Care bits
                                ; AL = Color Don't Care reg number
        out     dx,ax           ; "don't care" for all bit planes
;
; select output routine depnding on whether character is byte aligned
;
        mov     bl,Fore         ; BL = foreground color
        mov     bh,Back         ; BH = background color
        cmp     byte ptr [VARshift],0   ; test # bits to shift
        jne     L20             ; jump if character is not byte-aligned
;
; routine for byte aligned characters
;
        mov     al,8            ; AL = bit mask register number

L30:
;
; check for underlining next to last line
;
	cmp	cx,1		; last line?
	jne	short LuE	; nope
	test	[Hlmode],UNDFLG ; underlining on?
	jz	short LuE	 ; nope
	mov	ah,0FFh		; turn on all bits for underline
	jmp	short LdE	; done
LuE:
	mov     ah,es:[di]      ; AH = pattern for next row of pixels
LdE:
        out     dx,ax           ; update bit mask registre
        and     [si],bl         ; update foreground pixels

        not     ah
        out     dx,ax
        and     [si],bh         ; update background pixels

        inc     di              ; ES:DI - next byte in char def table
        add     si,BytesPerLine ; increment to next line in video buffer
        loop    L30          
        jmp     short Lexit
;
; routine for non-byte aligned characters
;
L20:    push    cx              ; preserve loop counter
;
; check for underlining next to last line
;
	cmp	cx,1		; last line?
	jne	short LuE1	; nope
	test	[Hlmode],UNDFLG ; underlining on?
	jz	short LuE1	 ; nope
	mov	al,0FFh		; turn on all bits for underline
	jmp	short LdE1	; done
LuE1:
;
; left side of character
;       
        mov     al,es:[di]      ; AL = bits for next row of pixels
LdE1:
        mov     cx,[VARshift]   ; CH = mask for left side of character
                                ; CL = # bits to shift left
        xor     ah,ah
        shl     ax,cl           ; AH = bits for left side of char
                                ; AL = bits for right side of char
        push    ax              ; save right side
        mov     al,8            ; Bit Mask Register number
        out     dx,ax           ; set bit mask for foreground pixels
        and     [si],bl         ; update foreground pixels

        not     ch              ; CH = mask for left side of char
        xor     ah,ch           ; AH = bits for background pixels
        out     dx,ax           ; set bit mask
        and     [si],bh         ; update background pixels
;
; right side of character
;
        pop     ax
        mov     ah,al           ; AH = bits for right side of char
        mov     al,8
        out     dx,ax           ; set bit mask

        inc     si              ; DS:SI - right side of char in buffer
        and     [si],bl         ; update foreground pixels

        not     ch              ; CH = mask for right side of char
        xor     ah,ch           ; AH = bits for background pixels
        out     dx,ax           ; set bit mask
        and     [si],bh         ; update background pixels
;
; increment to next row of pixels in character
;
        inc     di              ; ES:DI - next byte in char def table
        dec     si
        add     si,BytesPerLine ; DS:SI - next line in video buffer

        pop     cx
        loop    L20
;
; restore default Graphics Controller registers
;
Lexit:  mov     ax,0FF08h       ; default Bit Mask
        out     dx,ax

        mov     ax,0005         ; default Mode register
        out     dx,ax

        mov     ax,0003         ; default Data Rotate/Function Select
        out     dx,ax

        mov     ax,0FC7h        ; deffault Color Don't Care
        out     dx,ax

        pop     ds              ; get regs back
        pop     si
        pop     di
        mov     sp,bp
        pop     bp
        ret

_display_char10 ENDP

;
; PixelAddr10
;       Determine buffer address of pixel in Mode 0x0E
;
; Inputs:
;       AX = y coordinate (0-199)
;       BX = x coordinate (0-640)
;
; Returns:
;       AH = bit mask
;       BX = byte offset in buffer
;       CL = nubmer of bits to shift left
;       ES = video buffer segment
;
PixelAddr10 PROC NEAR
        mov     cl,bl           ; CL = low-order byte of x
        push    dx              ; preserve DX

        mov     dx,BytesPerLine ; AX = y * BytesPerLine
        mul     dx

        pop     dx
        shr     bx,1
        shr     bx,1
        shr     bx,1            ; BX = x/8
        add     bx,ax           ; BX = y*BytesPerLine + x/8
        add     bx,OriginOffset ; BX = byte offset in video buffer

        mov     ax,VideoBufferSeg
        mov     es,ax           ; ES:BX = byte address of pixel

        and     cl,7            ; CL = x & 7
        xor     cl,7            ; CL = nubmer of bits to shift left
        mov     ah,1            ; AH = unshifted bit mask
        ret
PixelAddr10 ENDP
;
; DisplayChar06( character ) - display a character in CGA Mode 6
;       int character - character to output
;  Just print a character at position Scrx, Scry with Foreground of
; Fgcolor and a background of Bgcolor
;
; Courtesy of "Programmer's Guide to PC & PS/2 Video Systems", Richard Wilton
;       MicroSoft Press, pp. 276-278
;
        PUBLIC _display_char06
_display_char06  PROC NEAR
        ARG     Character:WORD
        LOCAL   VARmask:WORD,VARtoggle:BYTE,Hlmode:WORD=AUTO_SIZE
        push    bp              ; preserve a few registers
        mov     bp,sp
        sub     sp,AUTO_SIZE    ; reserve some room for local vars
        push    di
        push    si
        push    ds

	mov	ax,_Win_hlmode	; save for later check
	mov	[Hlmode],ax
	cld			; make sure direction is postiive
;
; set up foreground pixel toggle mask
;
	mov	ah,_Fgcolor	; AH = 0 or 1 (foreground pixel value)
	ror	ah,1		; high-order bit of ah = 0 or 1
	cwd			; propagate high-order bit through DX
	not	dx		; DX =    0 if foreground = 1
				;      FFFF if foreground = 0
	mov	VARtoggle,dx
;
; calculate first pixel address
;
	mov	ax,_Scry	; AX = y
	mov	bx,_Scrx	; BX = x
	call	PixelAddr06	; ES:BX -> buffer
				; CL = # bits to shift left
	xor	cl,7		; CL = # bits to rotate right
	mov	ax,0FF00h
	ror	ax,cl		; AX = bit mask in proper position
	mov	VARmask,ax
;
; set up video buffer addressing
;
	mov	dx,2000h	; increment for video buffer interleave
	mov	di,80-2000h	; increment from last to first interleave
	test	bx,2000h	; set sero flag if BX in 1st interleave
	jz	CGA01
	xchg	di,dx		; exchange increment values if 1st pixel
				;  lies in 1st interleave
;
; set up character definition table addressing
;
CGA01:	push	bx		; preserve buffer address
	mov	ch,_Font_height	; CH = POINTS (pixel rows in char)
	mov	ax,0F000h	; point to character generator data
	mov	ds,ax		; DS = absolute zero
	mov	ax,[Character]	; AX = character code
CGA02:	mov	si,0FA6Eh	; DS:SI -> start of table
	mul	ch		; AX = offset into char def table
	add	si,ax		; SI = addr of char definition
	pop	bx		; restore buffer address
	test	cl,cl		; test # bits to rotate
	jnz	CGA20		; jump if character is not byte-aligned
;
; routine for byte aligned characters
;
	mov	ah,VARtoggle	; AH = foreground toggle mask
	xchg	ch,cl		; CX = points

CGA10:
	lodsb			; AL = bit pattern for next pixel row
;
; check for underlining next to last line
;
	cmp	cx,1		; last line?
	jne	short LdC	; nope
	test	[Hlmode],UNDFLG ; underlining on?
	jz	short LdC	 ; nope
	mov	al,0FFh		; turn on all bits for underline
LdC:
	xor	al,ah		; toggle pixels if foreground = 0
	mov	es:[bx],al	; store pixels in buffer
	add	bx,dx		; bx = next row in buffer
	xchg	di,dx		; swap buffer increments
	loop	CGA10
	jmp	short CGAexit
;
; routine for non-byte-aligned characters
;
CGA20:	mov	ax,VARmask
	and	es:[bx],ax	; mask character pixels in buffer
	xor	ah,ah
	lodsb			; AX = bit pattern for next pixel row
;
; check for underlining next to last line
;
	cmp	ch,1		; next to last line?
	jne	short LuC1	; nope
	test	[Hlmode],UNDFLG ; underlining on?
	jz	short LuC1	 ; nope
	mov	al,0FFh		; turn on all bits for underline
	jmp	short LdC1	; done
LuC1:
LdC1:
	xor	al,VARtoggle	; toggle pixels if foreground = 0
	ror	ax,cl		; rotate pixels into position
	or	es:[bx],ax	; store pixels in buffer
	add	bx,dx		; BX = next row in buffer
	xchg	di,dx		; swap buffer increments
	dec	ch
	jnz	CGA20

CGAexit: pop     ds              ; get regs back
        pop     si
        pop     di
        mov     sp,bp
        pop     bp
        ret
_display_char06 ENDP

;
; PixelAddr06
;       Determine buffer address of pixel in Mode 0x0E
;
; Inputs:
;       AX = y coordinate (0-199)
;       BX = x coordinate (0-640)
;
; Returns:
;       AH = bit mask
;       BX = byte offset in buffer
;       CL = number of bits to shift left
;       ES = video buffer segment
;
CGAVideoBufferSeg EQU	0B800h

PixelAddr06 PROC NEAR
	mov	cl,bl		; CL = low-order byte of x
	xchg	ah,al		; AX = 100h*y
	shr	bx,1		; x/2
	shr	ax,1		; 80h*(y&1)
	add	bh,al		; x/2 + 8000h*(y&1)
	xor	al,al		; 100h*(y/2)
	add	bx,ax		; x/2+8000h*(y&1)+140h*(y/2)
	shr	ax,1
	shr	ax,1		; 40h*(y/2)
	add	bx,ax		; x/2 + 8000h*(y&1) +140h*(y/2)
	shr	bx,1
	shr	bx,1		; x/8 + 2000h*(y&1) + 50h*(y/2)
	add	bx,OriginOffset ; BX == byte offset in video buffer
	mov	ax,CGAVideoBufferSeg
	mov	es,ax		; ES:BX = byte address of pixel
	and	cl,7
	xor	cl,7		; CL = nubmer of bits to shift left
	mov	ah,1		; unshifted bit mask
        ret
PixelAddr06 ENDP
	END


	TITLE	rodentia

_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
NULL	SEGMENT WORD PUBLIC 'BEGDATA'
NULL	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
EXTRN	_mouse_event_count:WORD
EXTRN	_mouse_queue_start:WORD
EXTRN	_mouse_event:WORD
EXTRN	_mouse_x:WORD
EXTRN	_mouse_y:WORD
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP CONST, _BSS, _DATA, NULL
	ASSUME CS: _TEXT, DS:DGROUP, SS:DGROUP, ES:DGROUP

_TEXT	SEGMENT
PUBLIC	_mouse, _get_mouse_event
; This is the interrupt handler.  Called with:
; AX = condition mask
; BX = button state
; CX = horizontal position (pixels)
; DX = vertical position (pixels)

_mouse	PROC	FAR 
	push	bp
	mov	bp,sp
	test	ax,6
	jz	mouret
	push	ds
	push	si
	push	di
	push	bx
	push	ax		; get a register
	mov	bx,_data
	mov	ds,bx		; get data space
	mov	ax,_mouse_event_count
	cmp	ax,4
	jge	moustr
	inc	_mouse_event_count
	jmp	short mouadd
moustr:	inc	_mouse_queue_start
mouadd:	mov	bx,_mouse_event_count
	dec	bx
	add	bx,_mouse_queue_start
	and	bx,3			; get the actual index
	shl	bx,1
	mov	di,bx
	mov	_mouse_x[di],cx
	mov	_mouse_y[di],dx
	pop	bx
	pop	ax
	mov	_mouse_event[di],ax
	pop	di
	pop	si
	pop	ds
mouret:	mov	sp,bp
	pop	bp
	ret			; ???

_mouse	ENDP

; Get an event from the queue, return 0 or 1 (0 means no event pending).
; BEWARE--RUNS WITH INTERRUPTS DISABLED
; first argument is three word table that gets data smashed into it.

_get_mouse_event PROC NEAR
	push	bp
	mov	bp,sp
	push	si
	push	di
	cli			; no interrupts
	mov	ax,_mouse_event_count
	cmp	ax,0
	jz	gmeout
	mov	ax,_mouse_queue_start
	dec	_mouse_event_count
	jle	mqsclr
	inc	_mouse_queue_start
	jmp	short gmecnt
mqsclr:	xor	bx,bx
	mov	_mouse_queue_start,bx
gmecnt: and	ax,3
	shl	ax,1
	mov	si,ax
	mov	di,[bp+4]
	mov	ax,_mouse_event[si]
	mov	[di],ax
	mov	ax,_mouse_x[si]
	mov	2[di],ax
	mov	ax,_mouse_y[si]
	mov	4[di],ax
	mov	ax,1
gmeout:	sti
	pop	di
	pop	si
	mov	sp,bp
	pop	bp
	ret

_get_mouse_event	ENDP

_TEXT	ENDS
END
	TITLE	speed

_TEXT	SEGMENT	BYTE PUBLIC 'CODE'
_TEXT	ENDS
NULL	SEGMENT WORD PUBLIC 'BEGDATA'
NULL	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
EXTRN	_dataspace:DWORD
EXTRN	_curblkloc:DWORD
EXTRN	_zpc1:WORD
EXTRN	_zpc2:WORD
EXTRN	_scrx:BYTE
EXTRN	_scry:BYTE
EXTRN	_screen:BYTE
_DATA	ENDS
CONST	SEGMENT	WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT	WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	CONST, _BSS, _DATA, NULL
	ASSUME	CS: _TEXT, DS: DGROUP, SS:DGROUP, ES:DGROUP

_TEXT	SEGMENT
	PUBLIC	_GTAWRD, _GTVWRD, _PTVWRD, _nxtbyt
	PUBLIC	_do_table_print, _do_intbl, _do_table_copy
	EXTRN	_newzpc:NEAR, _locate:NEAR, _datbyt:NEAR, _putchr:NEAR
	EXTRN	_getpag:NEAR, _flush_buffer:NEAR, _ppred:NEAR, _putval:NEAR

; Return the word at the pointer provided.
_GTAWRD	PROC	NEAR
	push	bp
	mov	bp,sp
	les	bx,DWORD PTR [bp+4]		; pick up the pointer
	mov	ax,es:[bx]
	xchg	ah,al				; right order...
	mov	sp,bp
	pop	bp
	ret
_GTAWRD	ENDP

; Return the word at the offset provided.  This assumes the offset is less
; than 64k, meaning we're in table space.  We can then safely add the offset
; to the offset part of the dataspace pointer to win...

_GTVWRD	PROC	NEAR
	push	bp
	mov	bp,sp
	les	bx,_dataspace
	add	bx,[bp+4]
	mov	ax,es:[bx]
	xchg	ah,al
	mov	sp,bp
	pop	bp
	ret
_GTVWRD	ENDP

_PTVWRD	PROC	NEAR
	push	bp
	mov	bp,sp
	les	bx,_dataspace
	add	bx,[bp+4]
	mov	ax,[bp+6]
	xchg	ah,al
	mov	es:[bx],ax
	mov	sp,bp
	pop	bp
	ret
_PTVWRD	ENDP

_nxtbyt	PROC	NEAR
	push	bp
	mov	bp,sp
	les	bx,_curblkloc
	add	bx,_zpc2
	mov	al,es:[bx]
	xor	ah,ah
	inc	_zpc2
	cmp	_zpc2,512
	jl	nxb1
	push	ax
	call	_newzpc
	pop	ax
nxb1:	mov	sp,bp
	pop	bp
	ret
_nxtbyt	ENDP

_do_table_print	PROC	NEAR
	push	si
	push	bp
	mov	bp,sp
	cmp	WORD PTR [bp+10],1
	jle	dtp1
	cmp	_screen,0
	jne	dtp1
	jmp	dtpend
dtp1:
	cmp	WORD PTR [bp+8],0		; no width
	jne	dtp2
	jmp	dtpend
dtp2:	cmp	WORD PTR [bp+10],0		; no height
	jne	dtp3
	jmp	dtpend
dtp3:	mov	al,_scry
	push	ax
	mov	al,_scrx
	push	ax
	mov	si,[bp+8]
	mov	ax,[bp+6]		; table pointer
	mov	cl,9
	shr	ax,cl			; get block number in ax
	push	ax			; save it
	mov	ax,[bp+6]
	and	ax,1FFH			; offset in block
	push	ax			; save it
	push	WORD PTR [bp-6]
	call	_getpag			; get a page pointer
	add	sp,2			; flush the arg
	mov	bx,ax
	mov	es,dx			; set up pointers
	add	bx,[bp-8]			; point to the right byte
dtplop:	push	bx			; save the pointers
	push	es
	mov	al,es:[bx]
	xor	ah,ah
	push	ax
	call	_putchr			; dump a character
	add	sp,2
	pop	es			; restore the pointers
	pop	bx
	dec	si			; decrement width
	jz	nxtlin			; jump if done with line
	inc	bx			; move to next character
	test	bx,1ffH			; see if done with page
	jz	nxtpag			; end of page
	jmp	dtplop			; just keep chugging
nxtlin:	dec	WORD PTR [bp+10]	; here if done with line.  dec height
	jz	dtpend			; all done
	push	bx
	push	es
	call	_flush_buffer		; nope, write buffer
	push	WORD PTR [bp-4]
	mov	ax,WORD PTR [bp-2]
	add	ax,8
	mov	WORD PTR [bp-2],ax
	push	ax
	call	_locate			; move the cursor
	add	sp,4
	pop	es
	pop	bx
	mov	ax,[bp-8]		; saved block offset
	add	ax,[bp+8]		; update it
	add	ax,[bp+12]
	cmp	ax,512			; are we past the page?
	jge	nxtlpg
	mov	[bp-8],ax		; nope, save for next time
	inc	bx
	add	bx,[bp+12]		; update the other offset
	mov	si,[bp+8]		; new count field
	jmp	dtplop			; go
nxtlpg:	inc	WORD PTR [bp-6]		; next page
	sub	ax,512
	mov	[bp-8],ax		; correct offset
	push	WORD PTR [bp-6]
	call	_getpag			; get new page pointer
	add	sp,2
	mov	es,dx
	mov	bx,ax
	add	bx,[bp+12]
	mov	si,WORD PTR [bp+8]
	jmp	dtplop
nxtpag:	inc	WORD PTR [bp-6]
	push	WORD PTR [bp-6]
	call	_getpag
	add	sp,2
	mov	es,dx
	mov	bx,ax
	xor	ax,ax
	mov	[bp-8],ax		; page offset is 0
	jmp	dtplop
dtpend:	mov	sp,bp
	pop	bp
	pop	si
	ret
_do_table_print	ENDP

_do_intbl	PROC	NEAR
	push	si
	push	di
	push	bp
	mov	bp,sp
	mov	ax,[bp+14]		; recspec
	xor	bx,bx
	test	ax,80H
	jz	di1
	xor	bx,-1
di1:	push	bx			; -1 if comparing words
	and	ax,07FH
	push	ax			; record length
	mov	ax,[bp+10]		; table
	mov	cl,9
	shr	ax,cl			; page number
	push	ax
	mov	ax,[bp+10]
	and	ax,1FFH			; offset
	mov	di,ax			; keep it handy
	push	WORD PTR [bp-6]
	call	_getpag			; get a page
	add	sp,2
	mov	es,dx
	add	ax,di			; make the offset right
	mov	si,ax			;es:[si] points to table
dimlop:	inc	WORD PTR [bp-2]
	jz	dicmpw
	xor	ah,ah
dilpc:	mov	al,es:[si]
	cmp	ax,[bp+8]
	je	diwon
	dec	WORD PTR [bp+12]
	jle	dilost
	add	si,[bp-4]
	add	di,[bp-4]
	cmp	di,512			; see if on next page
	jge	dinxtp
	jmp	dilpc
dicmpw:	mov	ax,es:[si]
	xchg	ah,al
	cmp	ax,[bp+8]
	je	diwon
	dec	WORD PTR [bp+12]
	jle	dilost
	add	si,[bp-4]
	add	di,[bp-4]
	cmp	di,512
	jl	dicmpw
	mov	ax,-1
	mov	[bp-2],ax
dinxtp:	inc	WORD PTR [bp-6]
	push	WORD PTR [bp-6]
	call	_getpag
	add	sp,2
	sub	di,512
	add	ax,di			; fix up offset
	mov	si,ax
	mov	es,dx
	jmp	dimlop
diwon:	mov	ax,[bp-6]		; page number
	mov	cl,9
	shl	ax,cl			; make it real
	add	ax,di			; add to pointer
	push	ax			; and return it
	call	_putval
	add	sp,2
	mov	ax,1			; also do the jump
	push	ax
	call	_ppred
	add	sp,2
diexit:	mov	sp,bp
	pop	bp
	pop	di
	pop	si
	ret
dilost:	xor	ax,ax
	push	ax
	call	_putval
	add	sp,2
	xor	ax,ax
	push	ax
	call	_ppred
	add	sp,2
	jmp	diexit

_do_intbl	ENDP

_do_table_copy	PROC	NEAR
	push	si
	push	di
	push	bp
	mov	bp,sp
	mov	bx,[bp+12]		; length
	cmp	bx,0
	jnz	dtc1
	jmp	short dtcret			; nothing to do
dtc1:	mov	ax,[bp+10]		; dest
	cmp	ax,[bp+8]		; same as source?
	jne	dtc2			; nope, got to do it
	jmp	short dtcret
dtc2:	cmp	ax,0
	jne	dtccop
; Here to zero a table (this will be fun)
	cld
	mov	ax,[bp+8]
	mov	cl,9
	shr	ax,cl
	push	ax			; page number
	call	_getpag			; get a pointer
	add	sp,2
	mov	es,dx
	mov	di,ax
	mov	ax,[bp+8]
	and	ax,1ffH			; get offset in page
	add	di,ax			; es:[di] is destination
	mov	cx,[bp+12]		; bytes to zero
	cmp	cx,0
	jg	dtc3
	mov	cx,[bp+12]
	neg	cx			; bozo gave us neg length
dtc3:	xor	al,al			; with 0, we hope
rep	stosb				; zero the sucker
dtcret:	mov	sp,bp
	pop	bp
	pop	di
	pop	si
	ret
; here to actually to string-to-string copy.  bx is length (also on stack),
; ax is dest.
dtccop:	cmp	bx,0			; if negative,...
	jge	dtcc1
	jmp	dtcfwd			; force forward copy
dtcc1:	cmp	ax,[bp+8]		; if dest < source, do forward
	jl	dtcfwd
	sub	ax,bx			; dest - length
	cmp	ax,[bp+8]		; dest - length >= source?
	jge	dtcfwd			; if so, we can do forward
; oops, have to do backwards copy, but at least we know the length is
; positive
	mov	ax,[bp+8]		; pick up source
	add	ax,[bp+12]
	dec	ax			; point to last byte to be copied
	push	ax			; let's save this...
	mov	cl,9
	shr	ax,cl
	push	ax			; [bp-4] will be page #
	push	ax			; let's save this, too
	call	_getpag			; last source page
	add	sp,2
	push	dx			; save what will be ds contents
	mov	si,ax
	mov	ax,[bp-2]		; saved address of end
	and	ax,1ffH			; offset in last page
	add	si,ax
	push	ax			; we'll need this in a second
	mov	ax,[bp+10]		; pick up dest
	mov	cl,9
	shr	ax,cl			; make it a page
	push	ax
	call	_getpag			; get pointer to FIRST target page
	add	sp,2
	mov	cx,[bp+10]
	and	cx,1ffH			; starting offset
	add	ax,cx
	add	ax,[bp+12]		; point to last target byte
	dec	ax			; really
	mov	es,dx
	mov	di,ax
	pop	cx			; offset in last source page
	inc	cx			; offset 1 at this point means 2 bytes
dbclop:	std
	cmp	cx,[bp+12]		; compare to length
	jle	dbc2
	mov	cx,[bp+12]		; don't copy more than you need
dbc2:	sub	[bp+12],cx		; update length
	pop	dx			; remember me?
	push	ds
	mov	ds,dx
rep	movsb				; do a batch
	cld				; reset direction flag
	pop	ds			; restore ds
	cmp	WORD PTR [bp+12],0
	jle	dtcret			; all done
	dec	WORD PTR [bp-4]		; go to previous page
	push	es			; es can get trashed
	push	WORD PTR [bp-4]
	call	_getpag			; get another source page
	add	sp,2
	pop	es
	push	dx			; this will pop presently
	mov	si,ax
	add	si,511			; point to last byte of page
	mov	cx,512			; max on this page
	jmp	dbclop			; go do it
; lets do a forward copy
dtcfwd:	cmp	bx,0
	jge	dfc1			; length is OK
	neg	bx
	mov	[bp+12],bx		; length is OK now
dfc1:	mov	ax,[bp+10]		; destination
	mov	cl,9
	shr	ax,cl
	push	ax
	call	_getpag			; destination page
	add	sp,2
	mov	es,dx
	mov	di,ax
	mov	ax,[bp+10]
	and	ax,1ffH
	add	di,ax			; es:[di] is ready
	mov	ax,[bp+8]		; source
	mov	cl,9
	shr	ax,cl
	push	ax			; save source page
	push	ax
	call	_getpag			; get source page
	add	sp,2
	push	ds			; save ds
	mov	ds,dx
	mov	si,ax
	mov	ax,[bp+8]
	and	ax,1ffH
	add	si,ax			; point to first source byte
	mov	cx,512			; bytes/page
	sub	cx,ax			; number we can copy here
dfclop:	cld				; make sure direction is OK
	cmp	cx,[bp+12]		; it's all on this page
	jl	dfc4			; if we don't jump
	mov	cx,[bp+12]
dfc4:	sub	[bp+12],cx		; update the length
rep	movsb				; copy a few
	pop	ds			; make sure ds is here
	cmp	WORD PTR [bp+12],0
	jg	dfc5
	jmp	dtcret			; all done
dfc5:	inc	WORD PTR [bp-2]			; next source page
	push	es
	push	WORD PTR [bp-2]
	call	_getpag
	add	sp,2
	pop	es
	push	ds
	mov	ds,dx
	mov	si,ax
	mov	cx,512
	jmp	dfclop

_do_table_copy	ENDP

_TEXT	ENDS
END


           Page  80,132
           Title Scroll - Verticle Scrolling Routines

;===========================================================================;
;                              Scroll source code                           ;
;                                                                           ;
;    Scroll and block clear routines for MCGA, VGA, EGA, and CGA graphics   ;
;                                                                           ;
;                              by John Fachini                              ;
;                      Inside Out Software Incorporated                     ;
;                      For exclusive use by Infocom, Inc.                   ;
;                                                                           ;
;                           Last modified:   5-12-89                        ;
;                           Version:          1.01                          ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                           Project specifications:                         ;
;                                                                           ;
; Graphics modes supported:         CGA   640 x 200   2 color               ;
;                                   EGA   640 x 200  16 color               ;
;                                   VGA   320 x 200 256 color               ;
;                                   MCGA  320 x 200 256 color               ;
;                                                                           ;
; Entry points:                                                             ;
;                                                                           ;
;      void cdecl scroll(x,y,width,height,lines,background)                 ;
;      unsigned int x,y;            /* upper left corner of scroll region */;
;      unsigned int width,height;   /* width, height of scroll region */    ;
;               int lines;          /* line count (negative scroll down) */ ;
;      unsigned char background;    /* fill color */                        ;
;                                                                           ;
; Global variables available at run-time:                                   ;
;                                                                           ;
;      unsigned char Display;       /* Display mode (1, 2, or 4) */         ;
;                                                                           ;
; The mission:                                                              ;
;                                                                           ;
;      Scroll region contents up or down, (based on the sign of 'lines').   ;
; If the line count to scroll is greater than or equal to the height of the ;
; graphics port, the region is cleared to the background color.  Otherwise  ;
; the scroll is completed and all blanked areas are cleared to the back-    ;
; ground color.                                                             ;
;                                                                           ;
; This source file should be assembled and it's OBJ file linked in with the ;
; TRIVIA.OBJ file.  Also note that version 1.04 or greater of Trivia is     ;
; required.                                                                 ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;           Assembled by the Microsoft Macro Assembler version 5.1          :
;                           Options: /V /W2 /Z /Mx                          ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                              Revision History:                            ;
;                                                                           ;
; Version 1.00   -   Initial working code.                                  ;
; Version 1.01   -   Fixed CGA, EGA border wrap bugs                        ;
;                                                                           ;
;***************************************************************************;
;                                                                           ;
;                 First released version to Infocom:    1.00                ;
;                                                                           ;
;===========================================================================;

           .MODEL  Small,C          ;small memory model, C language

;--------------------------------------------------------------------------
;  C function interface macro
;--------------------------------------------------------------------------
@FUNC      Macro FuncName,FuncParameters
	Public FuncName
FuncName   Proc FuncParameters                    ;declare public func
           IFNB  <FuncParameters>                    ;for any and all parms
           Irp   @FuncArg,<FuncParameters>           ;state parms to masm
           EndM
           EndIf
           EndM

;--------------------------------------------------------------------------
;  Stack interface macros
;--------------------------------------------------------------------------
@@CheckRegister Macro RegisterToCheck
           IfIdnI  <RegisterToCheck>,<SI>
@SI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DI>
@DI_Saved  =     1
           EndIf
           IfIdnI  <RegisterToCheck>,<DS>
@DS_Saved  =     1
           EndIf
           EndM


@LINK      Macro Reg1,Reg2,Reg3
@SI_Saved  =     0                                   ;clear each pushed
@DI_Saved  =     0                                   ;register variable
@DS_Saved  =     0                                   ;this invokation
           IFNB  <Reg1>                              ;check 1 of 3
           @@CheckRegister Reg1
           EndIf
           IFNB  <Reg2>                              ;check 2 of 3
           @@CheckRegister Reg2
           EndIf
           IFNB  <Reg3>                              ;check 3 of 3
           @@CheckRegister Reg3
           EndIf
           if    @SI_Saved                           ;if var says so,
           Push  SI                                  ;push the register
           EndIf
           If    @DI_Saved
           Push  DI
           EndIf
           If    @DS_Saved
           Push  DS
           EndIf
           EndM

@UNLINK    Macro
           If    @DS_Saved                           ;in reverse order as above
           Pop   DS
           EndIf
           If    @DI_Saved
           Pop   DI
           EndIf
           If    @SI_Saved
           Pop   SI
           EndIf
           Ret                                       ;C pops parms, not me
           EndM

;--------------------------------------------------------------------------
;  Graphics card and system variable equates  
;--------------------------------------------------------------------------
USE_CGA    equ   1                  ;'Display' value for CGA 640 x 200
USE_EGA    equ   2                  ;'Display' value for EGA 640 x 200
USE_VGA    equ   4                  ;'Display' value for VGA/MCGA 320 x 200

SEG_CGA    equ   0b800h             ;Segment of CGA video memory
SEG_EGA    equ   0a000h             ;Segment of EGA video memory
SEG_VGA    equ   0a000h             ;Segment of VGA video memory

;--------------------------------------------------------------------------
;  EGA Hardware equates and macros
;--------------------------------------------------------------------------
Plane_Select equ 3c4h               ;Plane select port
Mask_Select  equ 3ceh               ;Mask/Mode select port

;----------------------------------------------------------
; Used by most Out port routines (from the IBM tech-ref)
;----------------------------------------------------------
@OutDX     Macro
           Out   DX,AL
           Inc   DX
           Mov   AL,AH
           Out   DX,AL
           EndM

;--------------------------------------------------------------------------
; Select AH planes as write-able.  Bits 0 - 3 correspond to planes 0 - 3
;--------------------------------------------------------------------------
@WritePlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,2
           Mov   DX,Plane_Select
           @OutDX
           EndM

;-----------------------------------------------------------
; Enable a plane for reading: AH contains plane # (0 - 3)
;-----------------------------------------------------------
@ReadPlane Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,4
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------------------
; Enable writes to bits according to mask in AH (set bits are enabled)
;-------------------------------------------------------------------------
@WriteMask Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,8
           Mov   DX,Mask_Select
           @OutDX
           EndM

;----------------------------------------------------------
; Set a write mode given mode # in AH
;----------------------------------------------------------
@WriteMode Macro AHVal
           IfNB  <AHVal>
           Mov   AH,AHVal
           EndIf
           Mov   AL,3
           Mov   DX,Mask_Select
           @OutDX
           EndM

;-------------------------------------------------------------
; Set EGA graphics to normal write operations
;-------------------------------------------------------------
@NormalMode Macro
           @WriteMode 0
           EndM

;----------------------------------------------------------------------
; Reset the state of the EGA card: all planes, all bits enabled.
;----------------------------------------------------------------------
@ResetEGA  Macro
           @NormalMode
           @WritePlane 0fh
           @WriteMask 0ffh
           EndM

;************************ The real stuff starts here *************************

           .Data
;--------------------------------------------------------------------------
;  External variable declarations
;--------------------------------------------------------------------------
           Extrn Display          : Byte           ;display type field
           Extrn GrafSeg          : Word           ;from Trivia
           Extrn YTable           : Word           ;  "     "
           Extrn EGAScratch       : Byte           ;  "     "

CoordX0    dw    ?
CoordY0    dw    ?
CoordX1    dw    ?
CoordY1    dw    ?
PicWidth   dw    ?
PicHeight  dw    ?
PicLines   dw    ?
CurrentY   dw    ?
LineCount  dw    ?
TrueWidth  dw    ?
ByteOffset dw    ?
TransColor db    ?

;--------------------------------------------------------------------------
; Mask tables
;--------------------------------------------------------------------------
EMaskLeft  Label Byte               ;EGA mask (left)
CMaskLeft  Label Byte               ;CGA mask (left)
           db    00000000b
           db    01111111b
           db    00111111b
           db    00011111b
           db    00001111b
           db    00000111b
           db    00000011b
           db    00000001b
EMaskRight Label Byte               ;EGA mask (right)
CMaskRight Label Byte               ;CGA mask (right)
           db    10000000b
           db    11000000b
           db    11100000b
           db    11110000b
           db    11111000b
           db    11111100b
           db    11111110b
           db    00000000b
;--------------------------------------------------------------------------
; Scroll specific local storage
;--------------------------------------------------------------------------
LeftMask   db    0                  ;left mask applied to hline
RightMask  db    0                  ;right mask applied to hline
DeltaY     dw    0                  ;change in Y (1 or -1)
StartY     dw    0                  ;starting Y in scroll
DestY      dw    0                  ;dest Y in scroll
BoxY0      dw    0                  ;top line of region to fill after scroll
BoxY1      dw    0                  ;bottom line of region to fill

;************************** And finally... the code *************************

           .Code

           @FUNC iscroll,<X0:Word,Y0:Word,Wth:Word,Hth:Word,Lines:Word,BColor:Byte>
           @LINK SI,DI,DS
           Push  DS                 ;mov ES,DS
           Pop   ES                 ;the hard way
           Mov   AL,BColor          ;grab background color
           Mov   TransColor,AL      ;put it in the data segment
           Mov   AX,X0              ;upper left X co-ord
           Mov   BX,Y0              ;upper left Y co-ord
           Mov   CX,Wth             ;width in pixels (1 based)
           Mov   DX,Hth             ;height in lines (1 based)
           Mov   PicWidth,CX        ;remember width and
           Mov   PicHeight,DX       ;height for later
           Add   CX,AX              ;x1 = width  + x0 - 1
           Add   DX,BX              ;y1 = height + y0 - 1
           Dec   CX                 ;adjust for inclusive
           Dec   DX                 ;value calc
           Mov   CoordX0,AX         ;who needs range checking?
           Mov   CoordY0,BX         ;J.D. wouldn't pass bad data
           Mov   CoordX1,CX         ;right?
           Mov   CoordY1,DX         ;sure
           Mov   AX,Lines           ;line count (signed)
           Mov   BX,-1              ;default to 'up'
           Or    AX,AX              ;set sign bit
           Jns   Scroll0            ;scroll up it is
           Neg   AX                 ;|ax|
           Neg   BX                 ;--1
Scroll0:
           Mov   LineCount,AX       ;# of lines to move
           Mov   DeltaY,BX          ;direction value
           Mov   CX,CoordY0         ;CX = Y0
           Mov   DX,CoordY1         ;DX = Y1
	   Cld			    ; Make sure direction is correct
;--------------------------------------------------------------------------
; Given that AX is the absolute value of the 'lines' parameter, setup the
; starting conditions for variables.
; If the scroll is 'up' (i.e. DeltaY = -1):
;          StartY  =  Y0 + AX
;          DestY   =  Y0
;          BoxY0   =  Y1 - AX + 1
;          BoxY1   =  Y1
; If the scroll is 'down' (i.e. DeltaY = 1):
;          StartY  =  Y1 - AX
;          DestY   =  Y1
;          BoxY0   =  Y0
;          BoxY1   =  Y0 + AX - 1
; After the calcs are done, make LineCount = PicHeight - LineCount
; find the true number of lines to move.  If the result is <= 0, adjust
; BoxY0 = Y0 and BoxY1 = Y1 so that the region passed is cleared.
;--------------------------------------------------------------------------
           Cmp   DeltaY,-1          ;up or down?
           Je    Scroll_Up          ;up it is
Scroll_Down:
           Mov   StartY,DX
           Sub   StartY,AX          ;starty = y1 - ax
           Mov   DestY,DX           ;desty  = y1
           Mov   BoxY0,CX           ;boxy0  = y0
           Add   CX,AX
           Dec   CX
           Mov   BoxY1,CX           ;boxy1 = y0 + ax - 1
           Jmp   Short Scroll1      ;back to generalized code
Scroll_Up:
           Mov   StartY,CX
           Add   StartY,AX          ;starty = y0 + ax
           Mov   DestY,CX           ;desty  = y0
           Mov   BoxY1,DX           ;boxy1  = y1
           Sub   DX,AX
           Inc   DX
           Mov   BoxY0,DX           ;boxy0 = y1 - ax + 1
Scroll1:
           Mov   CX,PicHeight       ;height in lines
           Sub   CX,LineCount       ;take scroll count
           Mov   LineCount,CX       ;save it back
           Cmp   CX,0               ;check for sign bit or zero
           Jg    Scroll1_1          ;no problem, it's a 'normal' scroll
           Mov   AX,CoordY0         ;top Y
           Mov   BoxY0,AX           ;for large fill
           Mov   AX,CoordY1         ;bottom Y
           Mov   BoxY1,AX           ;adjusted
;--------------------------------------------------------------------------
; Check for an initialized variable set - if it's not setup, make it so
;--------------------------------------------------------------------------
Scroll1_1:
           Cmp   GrafSeg,0          ;uninit'd?
           Jne   Scroll5            ;all set - finish scroll specific setup
;--------------------------------------------------------------------------
; Setup GrafSeg with the appropriate value
;--------------------------------------------------------------------------
           Mov   AX,SEG_CGA         ;try CGA first
           Cmp   Display,USE_CGA    ;is this it?
           Je    Scroll2            ;yup
           Mov   AX,SEG_EGA         ;try EGA next (and since EGA/VGA same...)
Scroll2:
           Mov   GrafSeg,AX         ;save graphics seg
           Xor   AX,AX              ;AX = 0
           Mov   CX,200             ;Y table counter (always 200 for now)
           Mov   DI,Offset Dgroup:YTable ;ES:DI points into it
           Mov   BX,640/8           ;EGA line offset
           Cmp   Display,USE_CGA    ;is it the CGA version?
           Je    Scroll4            ;yes
           Cmp   Display,USE_EGA    ;EGA (guessed right?)
           Je    Scroll3            ;yes
           Mov   BX,320             ;byte per pixel (it's VGA)
Scroll3:
           StoSW                    ;YTable[0..199]
           Add   AX,BX              ;skip to next line
           Loop  Scroll3            ;200 times
           Jcxz  Scroll5            ;and continue with the Scroll code
Scroll4:
           Mov   DX,AX              ;current line number
           Mov   DH,DL              ;multiply by 256 (8 shifts left)
           And   DX,1feh            ;force into range (1 shifted with clr 0b)
           Shl   DX,1               ;*512
           Shl   DX,1               ;*1024
           Shl   DX,1               ;*2048
           Mov   BX,DX              ;working copy
           And   BH,7               ;gimmie lower 3 bits
           Shl   DX,1               ;still higher
           Shl   DX,1               ;last one (promise)
           Add   BX,DX              ;we've got interlace and offset now
           Xchg  AX,BX              ;setup AX as wanted value
           StoSW                    ;save the crazy result
           Xchg  AX,BX              ;back again to AX
           Inc   AX                 ;next line 0..199
           Loop  Scroll4            ;that's 200 lines
;--------------------------------------------------------------------------
; Lookup the masks and solid byte count for each line to be moved.
;--------------------------------------------------------------------------
Scroll5:
           Mov   LeftMask,0         ;reset the
           Mov   RightMask,0        ;mask values to none
           Mov   ES,GrafSeg         ;graphics segment in use
           Cmp   Display,USE_CGA    ;CGA?
           Je    Scroll_CGA         ;good guess
           Cmp   Display,USE_VGA    ;VGA?
           Je    Scroll_VGA         ;sure is
           Jmp   Scroll_EGA         ;default
;--------------------------------------------------------------------------
; Scroll_VGA: since VGA is a byte per pixel, 320 bytes per line linear
; addressing, there's no masking to set up.  The line width is PicWidth
; bytes.
;--------------------------------------------------------------------------
Scroll_VGA:
           Cmp   LineCount,0        ;scroll and fill or just fill?
           Jle   Scroll_VGA_3       ;just the box
;--------------------------------------------------------------------------
; Copy lines from StartY to DestY for LineCount lines.
;--------------------------------------------------------------------------
           Mov   BX,320             ;line offset (320 bytes per line)
           Cmp   DeltaY,-1          ;moving down through the buffer (up scr?)
           Je    Scroll_VGA_0       ;yes, use down offset
           Neg   BX                 ;-320
Scroll_VGA_0:
           Mov   SI,StartY          ;starting Y
           Mov   DI,DestY           ;where to copy it to
           Mov   DX,LineCount       ;# of lines to move
           Shl   SI,1               ;word lookup
           Shl   DI,1               ;word lookup
           Mov   SI,YTable[SI]      ;starting offset
           Mov   DI,YTable[DI]      ;starting offset
           Add   SI,CoordX0         ;adjust inward for X0
           Add   DI,CoordX0         ;same here
           Mov   AX,PicWidth        ;buffer width (byte per pixel)
           Push  ES                 ;DS and ES
           Pop   DS                 ;must both be graphics segment
Scroll_VGA_1:
           Mov   CX,AX              ;pixel count in bytes
           Push  SI                 ;save source index
           Push  DI                 ;and dest index
           Rep   MovSB              ;copy the lines
           Pop   DI                 ;restore index
           Pop   SI                 ;source too
           Add   DI,BX              ;adjust line offset
           Add   SI,BX              ;both places
           Dec   DX                 ;one less line
           Jne   Scroll_VGA_1       ;until all lines moved
           Push  SS                 ;recover C's DS
           Pop   DS                 ;by the SS method
;--------------------------------------------------------------------------
; Fill in a solid box from (BoxY0,CoordX0) (BoxY1,CoordX1) in TransColor.
;--------------------------------------------------------------------------
Scroll_VGA_3:                       ;clear box to TransColor
           Mov   DX,BoxY1           ;ending Y
           Mov   DI,BoxY0           ;'top' of fill area
           Sub   DX,DI              ;find difference (0 based) line count
           Shl   DI,1               ;word lookup
           Mov   DI,YTable[DI]      ;starting offset (ES:DI)
           Add   DI,CoordX0         ;X coord offset from left edge
           Mov   AL,TransColor      ;background color to fill with
           Mov   BX,320             ;line offset fixed at 320 bytes
Scroll_VGA_4:
           Mov   SI,DI              ;preserve starting DI for each line
           Mov   CX,PicWidth        ;byte per pixel
           Rep   StoSB              ;fill in the line
           Mov   DI,SI              ;restore starting offset
           Add   DI,BX              ;skip down to next line in the box
           Dec   DX                 ;one less line to clear
           Jns   Scroll_VGA_4       ;until all lines filled in
           Jmp   Exit               ;and return

;--------------------------------------------------------------------------
; Scroll_CGA: Find the left and right masks, the solid byte count in
; the middle of the line segment, and then do scroll/fill on those lines.
;--------------------------------------------------------------------------
Scroll_CGA:
           Mov   AX,PicWidth        ;width
           Mov   TrueWidth,AX       ;setup
           Mov   BX,CoordX0         ;starting X
           And   BX,7               ;mod 8 for table lookup
           Mov   AL,CMaskLeft[BX]   ;mask for left edge
           Mov   CX,8               ;8 - X0 mod 8
           Sub   CX,BX              ;are pixels used
           And   CX,7               ;mod 8 again
           Sub   TrueWidth,CX       ;pixel count
           Mov   LeftMask,AL        ;save it
           Mov   BX,CoordX1         ;right edge
           Mov   DX,BX              ;remember X1 for later
           And   BX,7               ;mod 8
           Mov   AL,CMaskRight[BX]  ;right edge
           Mov   RightMask,AL       ;save this one too
           Inc   BX                 ;+1
           And   BX,7               ;mod 8
           Sub   TrueWidth,BX       ;pixels used on right
           Mov   CL,3               ;2^3 = 8; 8 pixels per byte
           Mov   BX,CoordX0         ;DX = x1, BX = x0
           Shr   BX,CL              ;find which byte to start in
           Shr   DX,CL              ;and ending
           Mov   ByteOffset,BX      ;remember starting offset
           Shr   TrueWidth,1        ;truewidth /= 8
           Shr   TrueWIdth,1
           Shr   TrueWidth,1        ;to get # of solid bytes in line
           Cmp   BX,DX              ;same byte, starting & ending?
           Jne   Scroll_CGA_0       ;nope
           Mov   TrueWidth,0        ;yes
           Mov   AL,RightMask       ;intersection of masks
           Or    AL,AL              ;zero already?
           Je    Scroll_CGA_0       ;yes
           And   LeftMask,AL        ;is what's needed then
           Mov   RightMask,0        ;clear it
;--------------------------------------------------------------------------
; Check for box only, or scroll and box
;--------------------------------------------------------------------------
Scroll_CGA_0:
           Mov   BL,LeftMask        ;left side mask
           Mov   BH,RightMask       ;right side mask
           Cmp   LineCount,0        ;fill?
           Jle   Scroll_CGA_5       ;yes, forget scroll
;--------------------------------------------------------------------------
; CGA scroll
;--------------------------------------------------------------------------
Scroll_CGA_1:
           Mov   SI,StartY          ;current Y
           Mov   DI,DestY           ;ending Y
           Shl   SI,1               ;word lookup
           Shl   DI,1               ;on both
           Mov   SI,YTable[SI]      ;get true offsets from ES
           Mov   DI,YTable[DI]      ;on both
           Add   SI,ByteOffset      ;move in from left edge
           Add   DI,ByteOffset      ;bytes
           Mov   CX,TrueWidth       ;solid width
           Push  ES                 ;get DS == ES
           Pop   DS                 ;both graph seg
           Or    BL,BL              ;anything to mask on left?
           Je    Scroll_CGA_2       ;nope
           LodSB                    ;AL = source data
           And   AL,BL              ;strip unwanted bits
           Not   BL                 ;invert the mask
           And   ES:[DI],BL         ;clear dest bits
           Not   BL                 ;back to normal
           Or    ES:[DI],AL         ;write in new data
           Inc   DI                 ;and skip to next byte
Scroll_CGA_2:
           Jcxz  Scroll_CGA_3       ;no solid bytes in this line
           Rep   MovSB              ;there are... move me
Scroll_CGA_3:
           Or    BH,BH              ;right mask?
           Je    Scroll_CGA_4       ;nope
           LodSB                    ;source byte again
           And   AL,BH              ;right side this time
           Not   BH                 ;invert
           And   ES:[DI],BH         ;clear dest bits
           Not   BH                 ;restored
           Or    ES:[DI],AL         ;write in new bits
Scroll_CGA_4:
           Push  SS                 ;get C's
           Pop   DS                 ;DS back
           Mov   AX,DeltaY          ;offset value (1 or -1)
           Sub   StartY,AX          ;start and
           Sub   DestY,AX           ;end
           Dec   LineCount          ;one less to do
           Jne   Scroll_CGA_1       ;back to top
;--------------------------------------------------------------------------
; Now do the box fill
;--------------------------------------------------------------------------
Scroll_CGA_5:
           Mov   CX,TrueWidth       ;solid width in bytes
           Mov   DI,BoxY0           ;working towards Y1
           Shl   DI,1               ;word lookup
           Mov   DI,YTable[DI]      ;found
           Add   DI,ByteOffset      ;move in
           Mov   AH,TransColor      ;pixel value
           Or    AH,AH              ;zero or non-zero?
           Je    Scroll_CGA_6       ;zero
           Mov   AH,0ffh            ;set all bits
Scroll_CGA_6:
           Or    BL,BL              ;left mask?
           Je    Scroll_CGA_7       ;yes, forget it
           Mov   AL,AH              ;copy value
           And   AL,BL              ;strip bits
           Not   BL                 ;invert
           And   ES:[DI],BL         ;clear
           Or    ES:[DI],AL         ;set
           Inc   DI                 ;next byte
           Not   BL                 ;reset
Scroll_CGA_7:
           Jcxz  Scroll_CGA_8       ;no solid bytes
           Mov   AL,AH              ;fill value
           Rep   StoSB              ;write 'em in
Scroll_CGA_8:
           Or    BH,BH              ;right mask
           Je    Scroll_CGA_9       ;not there
           Mov   AL,AH              ;copy value
           And   AL,BH              ;mask
           Not   BH                 ;invert
           And   ES:[DI],BH         ;strip
           Or    ES:[DI],AL         ;set
           Not   BH                 ;reset the mask
Scroll_CGA_9:
           Inc   BoxY0              ;next Y down
           Mov   AX,BoxY1           ;copy
           Cmp   BoxY0,AX           ;done?
           Jle   Scroll_CGA_5       ;not yet
           Jmp   Exit               ;see ya

;--------------------------------------------------------------------------
; Scroll_EGA: Find the left and right masks, the solid byte count in
; the middle of the line segment, and then do scroll/fill on those lines.
;--------------------------------------------------------------------------
Scroll_EGA:
           Mov   AX,PicWidth        ;width
           Mov   TrueWidth,AX       ;setup
           Mov   BX,CoordX0         ;starting X
           And   BX,7               ;mod 8 for table lookup
           Mov   AL,EMaskLeft[BX]   ;mask for left edge
           Mov   CX,8               ;8 - X0 mod 8
           Sub   CX,BX              ;are pixels used
           And   CX,7               ;mod 8 again
           Sub   TrueWidth,CX       ;pixel count
           Mov   LeftMask,AL        ;save it
           Mov   BX,CoordX1         ;right edge
           Mov   DX,BX              ;remember X0 for later
           And   BX,7               ;mod 8
           Mov   AL,EMaskRight[BX]  ;right edge
           Mov   RightMask,AL       ;save this one too
           Inc   BX                 ;+1
           And   BX,7               ;mod 8
           Sub   TrueWidth,BX       ;pixels used on right
           Mov   CL,3               ;2^3 = 8; 8 pixels per byte
           Mov   BX,CoordX0         ;DX = x1, BX = x0
           Shr   BX,CL              ;find which byte to start in
           Shr   DX,CL              ;and ending
           Mov   ByteOffset,BX      ;remember starting offset
           Shr   TrueWidth,1        ;truewidth /= 8
           Shr   TrueWidth,1
           Shr   TrueWidth,1        ;to get # of solid bytes in line
           Cmp   BX,DX              ;same byte, starting & ending?
           Jne   Scroll_EGA_0       ;nope
           Mov   TrueWidth,0        ;yes
           Mov   AL,RightMask       ;intersection of masks
           Or    AL,AL              ;zero already?
           Je    Scroll_EGA_0       ;yes
           And   LeftMask,AL        ;is what's needed then
           Mov   RightMask,0        ;clear it
;--------------------------------------------------------------------------
; Check for box only, or scroll and box
;--------------------------------------------------------------------------
Scroll_EGA_0:
           Mov   BL,LeftMask        ;left side mask
           Mov   BH,RightMask       ;right side mask
           Cmp   LineCount,0        ;fill?
           Jg    Scroll_EGA_1       ;scroll and fill
           Jmp   Scroll_EGA_6       ;fill only
;--------------------------------------------------------------------------
; EGA scroll: start by copying the source line into EGAScratch
;--------------------------------------------------------------------------
Scroll_EGA_1:
           Mov   SI,StartY          ;current Y
           Shl   SI,1               ;word lookup
           Mov   SI,YTable[SI]      ;offset
           Mov   DI,Offset Dgroup:EGAScratch ;base internal line buffer
           Xor   AH,AH              ;starting plane = 0
           Push  ES                 ;set DS = video buffer
           Pop   DS                 ;done
           Push  SS                 ;set ES
           Pop   ES                 ;to C's DS for ES:DI EGAScratch
Scroll_EGA_1_0:
           @ReadPlane               ;read plane AH (0..3)
           Mov   AL,[SI]            ;latch
           Mov   CX,640/8           ;bytes per line
           Rep   MovSB              ;grab pels
           Sub   SI,640/8           ;adjust backwards
           Inc   AH                 ;next plane
           Cmp   AH,4               ;done yet?
           Jne   Scroll_EGA_1_0     ;nope
           @ResetEGA                ;yes, clean up card for now
           Push  ES                 ;push C's DS on stack
           Push  DS                 ;graf seg
           Pop   ES                 ;ES = graf seg
           Pop   DS                 ;DS = C's DS
           Mov   DI,DestY           ;ending Y
           Shl   DI,1               ;word lookup
           Mov   DI,YTable[DI]      ;offset from ES
           Mov   SI,Offset Dgroup:EGAScratch ;source data by plane
           Add   SI,ByteOffset      ;skip in this time
           Add   DI,ByteOffset      ;bytes too
           Mov   AH,1               ;plane counter
Scroll_EGA_2:
           Mov   CX,TrueWidth       ;solid width
           Push  AX                 ;save plane counter
           Push  SI                 ;save source index
           Push  DI                 ;and dest
           @WritePlane              ;enable plane AH
           Or    BL,BL              ;left mask?
           Je    Scroll_EGA_3       ;nope
           @WriteMask BL            ;bit mask
           Mov   AL,ES:[DI]         ;latch
           MovSB                    ;copy this plane's data with protect
Scroll_EGA_3:
           Jcxz  Scroll_EGA_4       ;no solid bytes in middle
           @WriteMask 0ffh          ;all bits
           Mov   AL,ES:[DI]         ;latch
           Rep   MovSB              ;copy
Scroll_EGA_4:
           Or    BH,BH              ;right side mask?
           Je    Scroll_EGA_5       ;nothing
           @WriteMask BH            ;set mask with protect
           Mov   AL,ES:[DI]         ;latch
           MovSB                    ;this plane
Scroll_EGA_5:
           Pop   DI                 ;restore source (since plane * 4)
           Pop   SI                 ;source pointer into EGAScratch
           Pop   AX                 ;recover plane counter from TOS
           Add   SI,640/8           ;bytes per line (don't touch DI)
           Shl   AH,1               ;next plane
           Cmp   AH,10h             ;done with planes?
           Jne   Scroll_EGA_2       ;not yet, do all 4 planes
           Mov   AX,DeltaY          ;offset value (1 or -1)
           Sub   StartY,AX          ;start and
           Sub   DestY,AX           ;end
           Dec   LineCount          ;one less to do
           Je    Scroll_EGA_6       ;done
           Jmp   Scroll_EGA_1       ;back for more
;--------------------------------------------------------------------------
; EGA box fill (CoordX0,BoxY0) (CoordX1,BoxY1) in TransColor
;--------------------------------------------------------------------------
Scroll_EGA_6:
           Mov   DI,BoxY0           ;starting Y in the box
           Shl   DI,1               ;*2
           Mov   DI,YTable[DI]      ;lookup
           Add   DI,ByteOffset      ;skip in
           Mov   CX,TrueWidth       ;solid byte count
           Or    BL,BL              ;left mask
           Je    Scroll_EGA_8       ;nothing to mask
           @WriteMask BL            ;enable bits in mask
           @WritePlane 0fh          ;all planes
           Mov   AL,ES:[DI]         ;latch plane
           Xor   AL,AL              ;black out
           Mov   ES:[DI],AL         ;left side
           Mov   AH,TransColor      ;color to fill with
           Or    AH,AH              ;black already?
           Je    Scroll_EGA_7       ;yes
           @WritePlane              ;setup the colors
           Mov   AL,0ffh            ;all bits
           Mov   ES:[DI],AL         ;write thru
Scroll_EGA_7:
           Inc   DI                 ;next screen byte
Scroll_EGA_8:
           Jcxz  Scroll_EGA_9       ;no solid bytes in midline
           @WriteMask 0ffh          ;all bits
           @WritePlane 0fh          ;all planes
           Push  DI                 ;preserve
           Push  CX                 ;these for pass 2
           Xor   AL,AL              ;black
           Rep   StoSB              ;nuke em
           Pop   CX                 ;byte counter back
           Pop   DI                 ;and offset
           Mov   AH,TransColor      ;color to fill with
           Or    AH,AH              ;black?
           Je    Scroll_EGA_9       ;no problem
           @WritePlane              ;pick planes in the color
           Mov   AL,0ffh            ;all bits
           Rep   StoSB              ;write the color into memory
           Jcxz  Scroll_EGA_10      ;skip adjust for no second stosb
Scroll_EGA_9:
           Add   DI,CX              ;adjust as if second stosb was done
Scroll_EGA_10:
           Or    BH,BH              ;right side mask this time
           Je    Scroll_EGA_11      ;nothing to do
           @WriteMask  BH           ;yet again
           @WritePlane 0ffh         ;all planes with protected bits
           Mov   AL,ES:[DI]         ;latch
           Xor   AL,AL              ;black
           Mov   ES:[DI],AL         ;write it in
           Mov   AH,TransColor      ;fill color
           Or    AH,AH              ;black?
           Je    Scroll_EGA_11      ;yes, get out
           @WritePlane              ;color planes selected
           Mov   AL,0ffh            ;all bits
           Mov   ES:[DI],AL         ;nuke non-protected bits
Scroll_EGA_11:
           @ResetEGA                ;cleanup temp
           Inc   BoxY0              ;next line down
           Mov   AX,BoxY0           ;get it locally
           Cmp   AX,BoxY1           ;done yet?
           Jg    Exit               ;yup
           Jmp   Scroll_EGA_6       ;nope, back for more
Exit:
           @UNLINK
iscroll     EndP

           End

;----------------------------------------------------------------------------

        NAME    c0yzip
        PAGE    60,132
;[]------------------------------------------------------------[]
;|      C0.ASM -- Start Up Code                                 |
;|                                                              |
;|      Turbo-C Run Time Library        version 2.0             |
;|                                                              |
;|      Copyright (c) 1988 by Borland International Inc.        |
;|      All Rights Reserved.                                    |
;[]------------------------------------------------------------[]

        INCLUDE RULES.ASI

__NOFLOAT__	equ	1	
_Strict87_	equ	false		; emulation skips peculiar details

;       Segment and Group declarations

_TEXT   SEGMENT BYTE PUBLIC 'CODE'
_TEXT   ENDS
_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS
_CRTSEG SEGMENT WORD COMMON 'DATA'
_CRTSEG ENDS
_BSS    SEGMENT WORD PUBLIC 'BSS'
_BSS    ENDS
_BSSEND SEGMENT BYTE PUBLIC 'STACK'
_BSSEND ENDS
_STACK  SEGMENT STACK 'STACK'
_STACK  ENDS


IF      LDATA
IFNDEF __HUGE__
DGROUP  GROUP   _DATA, _BSS, _BSSEND
ELSE
DGROUP  GROUP   _DATA,
ENDIF
ELSE
IFNDEF  __TINY__
DGROUP  GROUP   _DATA, _BSS, _BSSEND
ELSE
DGROUP  GROUP   _TEXT, _DATA,_BSS, _BSSEND
ENDIF
ENDIF


        ASSUME  CS:_TEXT, DS:DGROUP

;       External References

ExtProc@        main,   __CDECL__
ExtProc@        exit,   __CDECL__

IF      LDATA EQ false
ExtSym@ _heaplen, WORD,  __CDECL__
ENDIF
ExtSym@ _stklen,  WORD,  __CDECL__

        SUBTTL  Start Up Code
        PAGE
;/*                                                     */
;/*-----------------------------------------------------*/
;/*                                                     */
;/*     Start Up Code                                   */
;/*     -------------                                   */
;/*                                                     */
;/*-----------------------------------------------------*/
;/*                                                     */
PSPHigh         equ     00002h
PSPEnv          equ     0002ch
PSPCmd          equ     00080h

IFDEF	__NOFLOAT__
	MINSTACK	equ	128	; minimal stack size in words
ELSE
	MINSTACK	equ	256	; minimal stack size in words
ENDIF
;
;       At the start, DS and ES both point to the segment prefix.
;       SS points to the stack segment except in TINY model where
;       SS is equal to CS
;
_TEXT   SEGMENT
IFDEF   __TINY__
        ORG     100h
ENDIF
STARTX          PROC    NEAR
;       Save general information, such as :
;               DGROUP segment address
;               DOS version number
;               Program Segment Prefix address
;               Environment address
;               Top of far heap

IFDEF   __TINY__
                mov     dx, cs          ; DX = GROUP Segment address
ELSE
                mov     dx, DGROUP      ; DX = GROUP Segment address
ENDIF
                mov     cs:DGROUP@@, dx
                mov     ah, 30h
                int     21h
                mov     bp, ds:[PSPHigh]; BP = Highest Memory Segment Addr
                mov     bx, ds:[PSPEnv] ; BX = Environment Segment address
                mov     ds, dx
                mov     _version@, ax   ; Keep major and minor version number
                mov     _psp@, es       ; Keep Program Segment Prefix address
                mov     _envseg@, bx    ; Keep Environment Segment address
                mov     word ptr _heaptop@ + 2, bp
                mov     _8087@, -1
;
;       Save several vectors and install default divide by zero handler.
;
;                call    SaveVectors

IF      LDATA
                mov     dx, ss
                sub     bp, dx          ; BP = remaining size in paragraphs
IFDEF   __HUGE__
                mov     di, seg _stklen@
                mov     es, di
                mov     di, es:_stklen@ ; DI = Requested stack size
ELSE
                mov     di, _stklen@    ; DI = Requested stack size
ENDIF
;
; Make sure that the requested stack size is at least MINSTACK words.
;
                cmp     di, 2*MINSTACK  ; requested stack big enough ?
                jae     AskedStackOK
                mov     di, 2*MINSTACK  ; no --> use minimal value
IFDEF   __HUGE__
                mov     es:_stklen@, di ; override requested stack size
ELSE
                mov        _stklen@, di ; override requested stack size
ENDIF
AskedStackOK    label   near
                mov     cl, 4
                shr     di, cl          ; $$$ Do not destroy CL $$$
                inc     di              ; DI = Stack size in paragraphs
                cmp     bp, di
                jnb     ExcessOfMemory  ; Much more available than needed
ELSE
                mov     dx, ds
                sub     bp, dx          ; BP = remaining size in paragraphs
                mov     di, _stklen@    ; DI = Requested stack size
;
; Make sure that the requested stack size is at least MINSTACK words.
;
                cmp     di, 2*MINSTACK  ; requested stack big enough ?
                jae     AskedStackOK
                mov     di, 2*MINSTACK  ; no --> use minimal value
                mov     _stklen@, di    ; override requested stack size
AskedStackOK    label   near
                add     di, offset DGROUP: edata@
;                jb      InitFailed      ; DATA segment can NOT be > 64 Kbytes
                add     di, _heaplen@
;                jb      InitFailed      ; DATA segment can NOT be > 64 Kbytes
                mov     cl, 4
                shr     di, cl          ; $$$ Do not destroy CL $$$
                inc     di              ; DI = DS size in paragraphs
                cmp     bp, di
;                jb      InitFailed      ; Not enough memory
                cmp     _stklen@, 0
                je      ExpandDS        ; Expand DS up to 64 Kb
                cmp     _heaplen@, 0
                jne     ExcessOfMemory  ; Much more available than needed
ExpandDS        label   near
                mov     di, 1000h
                cmp     bp, di
                ja      ExcessOfMemory  ; Enough to run the program
                mov     di, bp
                jmp     short ExcessOfMemory  ; Enough to run the program
ENDIF

;       All initialization errors arrive here

;InitFailed      label   near
;                jmp     near ptr abort@

;       Return to DOS the amount of memory in excess
;       Set far heap base and pointer

ExcessOfMemory  label   near
                mov     bx, di
                add     bx, dx
                mov     word ptr _heapbase@ + 2, bx
                mov     word ptr _brklvl@ + 2, bx
                mov     ax, _psp@
                sub     bx, ax          ; BX = Number of paragraphs to keep
                mov     es, ax          ; ES = Program Segment Prefix address
                mov     ah, 04Ah
                push    di              ; preserve DI
                int     021h            ; this call clobbers SI,DI,BP !!!!!!
                pop     di              ; restore  DI
;
;	Set the program stack.  Take care to prevent the disastrous
;	interrupt that could happen with a stack that is half switched.
;
                shl     di, cl          ; $$$ CX is still equal to 4 $$$

		cli
                mov     ss, dx
                mov     sp, di
		sti

IFNDEF  __HUGE__

;       Reset uninitialized data area

                xor     ax, ax
                mov     es, cs:DGROUP@@
                mov     di, offset DGROUP: bdata@
                mov     cx, offset DGROUP: edata@
                sub     cx, di
	        rep     stosb
ENDIF

;       Prepare main arguments

                mov	ah, 0
                int	1ah			; get current BIOS time in ticks
                mov	word ptr _StartTime@,dx	; save it for clock() fn
                mov	word ptr _StartTime@+2,cx

IFDEF XXXXX                
IFNDEF  __OLDCONIO__
IF      LPROG
                push    cs              ; Simulation of a FAR call
ENDIF
                call    ds:[__crt1st]   ; Initialize window sizes, etc.
ENDIF
ENDIF

;       ExitCode = main(argc,argv,envp);

IFDEF   XXXXX
IF      LDATA
                push    word ptr environ@+2
                push    word ptr environ@
                push    word ptr _argv@+2
                push    word ptr _argv@
ELSE
                push    word ptr environ@
                push    word ptr _argv@
ENDIF
                push    _argc@
ENDIF
                mov     _8087@, 0               ; show no emulator
                call    main@

;       Flush and close streams and files

                push    ax
                call    exit@
STARTX          ENDP
IFDEF   XXXXX
;---------------------------------------------------------------------------
;	_exit()
;
;       Restore interrupt vectors taken during startup.  signal() functions
;	could have grabbed vectors 0, 4, 5 or 6.
;
;	Check for NULL pointer errors.
;
;	Exit to DOS.
;
;NOTE : _exit() doesn't close any files or run exit functions.  This is a
;	minimal 'cleanup & quit' program exit.
;---------------------------------------------------------------------------
PubProc@        _exit,  __CDECL__
                mov     ds, cs:DGROUP@@

IF      LPROG
                call    far ptr _restorezero@	; restore captured INT vectors
ELSE
                call    near ptr _restorezero@
ENDIF

IFNDEF  __NOFLOAT__

;       Restore interrupt vectors taken by __emu1st

                push    cs              ;Simulation of a FAR call
                call    ds:[__emuLast]
ENDIF

IF      LDATA EQ false
IFNDEF  __TINY__

;       Check for null pointers before exit

                xor     ax, ax
                mov     si, ax
                mov     cx, lgth_CopyRight
                cld
ComputeChecksum label   near
                add     al, [si]
                adc     ah, 0
                inc     si
                loop    ComputeChecksum
                sub     ax, CheckSum
                jz      ExitToDOS
                mov     cx, lgth_NullCheck
                mov     dx, offset DGROUP: NullCheck
                call    ErrorDisplay
ENDIF
ENDIF

;       Exit to DOS

ExitToDOS       label   near
                mov     bp,sp
                mov     ah,4Ch
                mov     al,[bp+cPtrSize]
                int     21h                     ; Exit to DOS
EndProc@        _exit, __CDECL__

        SUBTTL  Vector save/restore & default Zero divide routines
        PAGE
;[]------------------------------------------------------------[]
;|                                                              |
;| Interrupt Save/Restore routines and default divide by zero   |
;| handler.                                                     |
;|                                                              |
;[]------------------------------------------------------------[]

ZeroDivision    PROC    FAR
                mov     cx, lgth_ZeroDivMSG
                mov     dx, offset DGROUP: ZeroDivMSG
                jmp     MsgExit3
ZeroDivision    ENDP

;--------------------------------------------------------------------------
;	savevectors()
;
;	Save vectors for 0, 4, 5 & 6 interrupts.  This is for extended
;	signal()/raise() support as the signal functions can steal these
;	vectors during runtime.
;--------------------------------------------------------------------------
SaveVectors	PROC    NEAR
                push    ds
; Save INT 0
                mov     ax, 3500h
                int     021h
                mov     word ptr _Int0Vector@, bx
                mov     word ptr _Int0Vector@+2, es
; Save INT 4
                mov     ax, 3504h
                int     021h
                mov     word ptr _Int4Vector@, bx
                mov     word ptr _Int4Vector@+2, es
; Save INT 5
                mov     ax, 3505h
                int     021h
                mov     word ptr _Int5Vector@, bx
                mov     word ptr _Int5Vector@+2, es
; Save INT 6
                mov     ax, 3506h
                int     021h
                mov     word ptr _Int6Vector@, bx
                mov     word ptr _Int6Vector@+2, es
;
;	Install default divide by zero handler.
;
                mov     ax, 2500h
                mov     dx, cs
                mov     ds, dx
                mov     dx, offset ZeroDivision
                int     21h

                pop     ds
                ret
SaveVectors	ENDP

;--------------------------------------------------------------------------
;	restorezero() puts back all the vectors that SaveVectors took.
;
;NOTE : TSRs must BE AWARE that signal() functions which take these 
;	vectors will be deactivated if the keep() function is executed.
;	If a TSR wants to use the signal functions when it is active it 
;	will have to save/restore these vectors itself when activated and
;	deactivated.
;--------------------------------------------------------------------------
PubProc@        _restorezero, __CDECL__

IFDEF   __HUGE__
                push    ds
                mov     ds, cs: DGROUP@@
ENDIF
                push    ds
                mov     ax, 2500h
                lds     dx, _Int0Vector@
                int     21h
		pop	ds

		push	ds
                mov     ax, 2504h
                lds     dx, _Int4Vector@
                int     21h
		pop	ds

		push	ds
                mov     ax, 2505h
                lds     dx, _Int5Vector@
                int     21h
		pop	ds

IFNDEF   __HUGE__
		push	ds
ENDIF
                mov     ax, 2506h
                lds     dx, _Int6Vector@
                int     21h
                pop     ds

                ret
EndProc@        _restorezero, __CDECL__

        SUBTTL  Miscellaneous
        PAGE
;[]------------------------------------------------------------[]
;|                                                              |
;|      Miscellaneous functions                                 |
;|                                                              |
;[]------------------------------------------------------------[]

IFNDEF  __NOFLOAT__
NoEmulator      PROC    FAR
                ret
NoEmulator      ENDP
ENDIF

IFNDEF  __OLDCONIO__
Proc@           NoConsole, __CDECL__
                ret
EndProc@        NoConsole, __CDECL__
ENDIF

ErrorDisplay    PROC    NEAR
                mov     ah, 040h
                mov     bx, 2
                int     021h
                ret
ErrorDisplay    ENDP

ENDIF
PubProc@        abort,  __CDECL__
                mov     cx, lgth_abortMSG
                mov     dx, offset DGROUP: abortMSG
MsgExit3        label   near
                mov     ds, cs: DGROUP@@
;                call    ErrorDisplay
CallExit3       label   near
                mov     ax, 3
                push    ax
                call    _exit          ; _exit(3);
EndProc@        abort, __CDECL__
                mov     _8087@, 0
;       The DGROUP@ variable is used to reload DS with DGROUP

PubSym@ DGROUP@, <dw    ?>, __PASCAL__
_TEXT   ENDS

        SUBTTL  Start Up Data Area
        PAGE
;[]------------------------------------------------------------[]
;|      Start Up Data Area                                      |
;|                                                              |
;|      WARNING         Do not move any variables in the data   |
;|                      segment unless you're absolutely sure   |
;|                      that it does not matter.                |
;|                                                              |
;[]------------------------------------------------------------[]

_DATA   SEGMENT

;       The CopyRight string must NOT be moved or changed without
;       changing the null pointer check logic

CopyRight       db      4 dup(0)
                db      'Turbo-C - Copyright (c) 1988 Borland Intl.',0
lgth_CopyRight  equ     $ - CopyRight

IF      LDATA EQ false
IFNDEF  __TINY__
CheckSum        equ     00D37h
NullCheck       db      'Null pointer assignment', 13, 10
lgth_NullCheck  equ     $ - NullCheck
ENDIF
ENDIF

ZeroDivMSG      db      'Divide error', 13, 10
lgth_ZeroDivMSG equ     $ - ZeroDivMSG

abortMSG        db      'Abnormal program termination', 13, 10
lgth_abortMSG   equ     $ - abortMSG

;
;			Interrupt vector save areas
;	
;	Interrupt vectors 0,4,5 & 6 are saved at startup and then restored
;	when the program terminates.  The signal/raise functions might
;	steal these vectors during execution.
;
PubSym@         _Int0Vector	<dd     0>,             __CDECL__
PubSym@         _Int4Vector	<dd     0>,             __CDECL__
PubSym@         _Int5Vector	<dd     0>,             __CDECL__
PubSym@         _Int6Vector	<dd     0>,             __CDECL__
;
;			Miscellaneous variables
;	
PubSym@         _argc,          <dw     0>,             __CDECL__
dPtrPub@        _argv,          0,                      __CDECL__
dPtrPub@        environ,        0,                      __CDECL__
PubSym@         _envLng,        <dw     0>,             __CDECL__
PubSym@         _envseg,        <dw    0>,              __CDECL__
PubSym@         _envSize,       <dw    0>,              __CDECL__
PubSym@         _psp,           <dw    0>,              __CDECL__
PubSym@         _version,       <label word>,           __CDECL__
PubSym@         _osmajor,       <db    0>,              __CDECL__
PubSym@         _osminor,       <db    0>,              __CDECL__
PubSym@         errno,          <dw    0>,              __CDECL__
PubSym@         _8087,          <dw    0>,              __CDECL__
PubSym@         _StartTime,     <dw    0,0>,            __CDECL__


;       Memory management variables

IF      LDATA EQ false
PubSym@         __heapbase,     <dw   DGROUP:edata@>,   __CDECL__
PubSym@         __brklvl,       <dw   DGROUP:edata@>,   __CDECL__
PubSym@         __heaptop,      <dw   DGROUP:edata@>,   __CDECL__
ENDIF
PubSym@         _heapbase,      <dd   0>,       __CDECL__
PubSym@         _brklvl,        <dd   0>,       __CDECL__
PubSym@         _heaptop,       <dd   0>,       __CDECL__

IF	LDATA EQ false
	IFNDEF	__NOFLOAT__
;				Emulator variables
		INCLUDE	emuvars.asi
	ENDIF
ENDIF

_DATA   ENDS

IFDEF XXXXX
IFNDEF  __NOFLOAT__
_EMUSEG SEGMENT
__emu1st        dw      NoEmulator
__emuLast       dw      NoEmulator
_EMUSEG ENDS
ENDIF

ENDIF

IFNDEF __HUGE__
_BSS    SEGMENT
bdata@  label   byte
_BSS    ENDS

_BSSEND SEGMENT
edata@  label   byte
_BSSEND ENDS
ENDIF

IFNDEF  __TINY__
_STACK  SEGMENT
        dw      64 dup (?)
	IF	LDATA
		org	0
		IFNDEF	__NOFLOAT__
;						Emulator variables
			INCLUDE	emuvars.asi
			even
		ENDIF
PUBLIC		emuTop@			; for use in stack-underflow checks.
		emuTop@	label	byte
	ENDIF
_STACK  ENDS
ENDIF
        END     STARTX
	TITLE	library

_TEXT	SEGMENT	BYTE PUBLIC 'CODE'
_TEXT	ENDS
NULL	SEGMENT WORD PUBLIC 'BEGDATA'
NULL	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
	PUBLIC ___argv,___argc,__osfile
	PUBLIC __dosvermajor, __dosverminor, __osversion
	PUBLIC __doserrno
	PUBLIC _acfinfo, __child, __fac, __intno, __nfile, __oserr
	PUBLIC __osmode, __ovlflag, __ovlvec, __pgmptr
	PUBLIC __psprdr, __umaskval

_acfinfo dw 0
__child	     dw 0
__fac	     dw 0
__intno	     dw 0
__nfile	     dw 0
__oserr	     dw 0
__osfile     dw 0
__osmode     dw 0
__ovlflag    dw 0
__ovlvec     dw 0
__pgmptr     dw 0
__psprdr     dw 0
__umaskval	dw 0
__doserrno dw 0
__dosvermajor dw 0
__dosverminor dw 0
__osversion dw 0
___argv dw 0
___argc dw 0

_DATA	ENDS
CONST	SEGMENT	WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT	WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	CONST, _BSS, _DATA, NULL
	ASSUME	CS: _TEXT, DS: DGROUP, SS:DGROUP, ES:DGROUP

_TEXT	SEGMENT
	PUBLIC	_int86,_int86x,_kbhit
	PUBLIC __dosret0, __dosretax, __cinit, _exit, __exit, __ctermsub
	PUBLIC __NMSG_TEXT,__NMSG_WRITE
	PUBLIC __fptrap

__fptrap	PROC	NEAR
	ret
__fptrap	ENDP

__NMSG_TEXT	PROC	NEAR
	ret
__NMSG_TEXT	ENDP

__NMSG_WRITE	PROC	NEAR
	ret
__NMSG_WRITE	ENDP

__ctermsub	PROC	NEAR
	ret
__ctermsub	ENDP

_exit	PROC	NEAR
	xor	ax,ax
	call	__exit
_exit	ENDP

__exit	PROC	NEAR
	xor	al,al
	mov	ah,4CH
	int	21H
__exit	ENDP

__cinit	PROC	NEAR
	ret
__cinit	ENDP

__dosret0	PROC	NEAR
	xor	ax,ax
	mov	sp,bp
	pop	bp
	ret
__dosret0	ENDP

__dosretax	PROC	NEAR
	mov	sp,bp
	pop	bp
	ret
__dosretax	ENDP

_int86	PROC	NEAR
	push	bp		; transcribed from library
	mov	bp,sp
	push	si
	push	di
	sub	sp,0AH		; make space on the stack
	mov	BYTE PTR [bp-0AH],0CDH
	mov	ax,[bp+4]
	mov	[bp-9],al
	mov	BYTE PTR [bp-8],0CBH
	mov	[bp-0CH],ss
	lea	ax,[bp-0AH]
	mov	[bp-0EH],ax
	mov	di,[bp+6]
	mov	ax,[di]
	mov	bx,[di+2]
	mov	cx,[di+4]
	mov	dx,[di+6]
	mov	si,[di+8]
	mov	di,[di+0AH]
	push	bp
	sub	bp,0EH
	call	DWORD PTR [bp+0]
	pop	bp
	push	di
	mov	di,[bp+8]
	mov	[di],ax
	mov	[di+2],bx
	mov	[di+4],cx
	mov	[di+6],dx
	mov	[di+8],si
	pop	WORD PTR [di+0AH]
	jb	intlos
	xor	si,si
	jmp	short intret
intlos:	mov	si,1
intret:	mov	ax,[di]
	mov	[di+0CH],si
	add	sp,0AH
	cld
	pop	di
	pop	si
	mov	sp,bp
	pop	bp
	ret
_int86	ENDP

_int86x	PROC	NEAR
	push	bp		; transcribed from library
	mov	bp,sp
	push	si
	push	di
	sub	sp,0AH		; make space on the stack
	mov	BYTE PTR [bp-0AH],0CDH
	mov	ax,[bp+4]
	mov	[bp-9],al
	mov	BYTE PTR [bp-8],0CBH
	mov	[bp-0CH],ss
	lea	ax,[bp-0AH]
	mov	[bp-0EH],ax
	mov	di,[bp+6]
	mov	ax,[di]
	mov	bx,[di+2]
	mov	cx,[di+4]
	mov	dx,[di+6]
	mov	si,[di+8]
	mov	di,[di+0AH]
	push	ds
	push	es
	push	ax
	mov	ax,[bp+0AH]		; which register to load
	cmp	ax,2			; DS?
	je	intds
	mov	es,[bp+0CH]		; es
	jmp	short intxdo
intds:	mov	ds,[bp+0CH]
intxdo:	pop	ax
	push	bp
	sub	bp,0EH
	call	DWORD PTR [bp]		; this actually does the call
	pop	bp
	mov	ax,[bp+0AH]
	cmp	ax,2
	je	savds
	mov	[bp+0CH],es
	jmp	short inrxrt
savds:	mov	[bp+0CH],ds
inrxrt:	pop	es
	pop	ds			; restore segment registers
	push	di
	mov	di,[bp+8]
	mov	[di],ax
	mov	[di+2],bx
	mov	[di+4],cx
	mov	[di+6],dx
	mov	[di+8],si
	pop	WORD PTR [di+0AH]
	jb	inxlos
	xor	si,si
	jmp	short inxret
inxlos:	mov	si,1
inxret:	mov	ax,[di]
	mov	[di+0CH],si
	add	sp,0AH
	cld
	mov	ax,[bp+0CH]		; return the register we set...
	pop	di
	pop	si
	mov	sp,bp
	pop	bp
	ret
_int86x	ENDP

_kbhit	PROC	NEAR
	push	bp
	mov	bp,sp
	mov	ah,1
	int	16H		; keyboard service
	jz	nohit
	mov	ax,1
kbret:	mov	sp,bp
	pop	bp
	ret
nohit:	xor	ax,ax
	jmp	short kbret
_kbhit	ENDP



_TEXT	ENDS
END

